Index: barebox-2014.10.0/drivers/video/s3c64xx.c
===================================================================
--- /dev/null
+++ barebox-2014.10.0/drivers/video/s3c64xx.c
@@ -0,0 +1,389 @@
+/*
+ * Copyright (C) 2010 Juergen Beisert
+ * Copyright (C) 2011 Alexey Galakhov
+ * Copyright (C) 2013 liang kang nan
+ *
+ * This driver is based on a patch found in the web:
+ * (C) Copyright 2006 by OpenMoko, Inc.
+ * Author: Harald Welte <laforge at openmoko.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ */
+
+#include <common.h>
+#include <init.h>
+#include <fb.h>
+#include <driver.h>
+#include <malloc.h>
+#include <errno.h>
+#include <io.h>
+#include <mach/s3c-generic.h>
+#include <mach/s3c24xx-fb.h>
+
+
+/* special function regs offset based diaplay control */
+#define VIDCON0          0x00
+#define CLKVAL_F(x)      ((x) << 6)
+#define CLKDIR           (1 << 4)
+#define ENVID            (1 << 1)
+#define ENVID_F          (1 << 0)
+
+#define VIDCON1          0x04
+#define IVCLK            (1 << 7)
+#define IHSYNC           (1 << 6)
+#define IVSYNC           (1 << 5)
+
+#define VIDCON2          0x08
+
+#define VIDTCON0         0x10
+#define VBPD(x)          ((x) << 16)
+#define VFPD(x)          ((x) << 8)
+#define VSPW(x)          ((x) << 0)
+
+#define VIDTCON1         0x14
+#define HBPD(x)          ((x) << 16)
+#define HFPD(x)          ((x) << 8)
+#define HSPW(x)          ((x) << 0)
+
+#define VIDTCON2         0x18
+#define LINEVAL(x)       ((x) << 11)
+#define HOZVAL(x)        ((x) << 0)
+
+#define WINCON0          0x20
+#define BPPMODE_F(x)     ((x) << 2)
+#define ENWIN_F          (1 << 0)
+
+#define VIDOSD0A         0x40
+#define LEFTTOPX_F(x)    ((x) << 11)
+#define LEFTTOPY_F(x)    ((x) << 0)
+
+#define VIDOSD0B         0x44
+#define RIGHTBOTX_F(x)   ((x) << 11)
+#define RIGHTBOTY_F(x)   ((x) << 0)
+
+#define VIDOSD0C         0x48
+#define VIDW00ADD0B0     0xA0
+#define VIDW00ADD0B1     0xA4
+#define VIDW00ADD1B0     0xD0
+#define VIDW00ADD1B1     0xD4
+#define VIDW00ADD2       0x100
+
+#define VIDINTCON0       0x130
+#define VIDINTCON1       0x134
+#define DITHMODE         0x170
+#define WIN0MAP          0x180
+#define TRIGCON          0x1A4
+
+/*  */
+#define MIFPCON          (*((volatile unsigned long *)0x7410800C))
+#define SPCON            (*((volatile unsigned long *)0x7F0081A0))
+
+/* LCD IO */
+#define GPICON           (*((volatile unsigned long *)0x7F008100))
+#define GPJCON           (*((volatile unsigned long *)0x7F008120))
+/* LCD on/off */
+#define GPECON           (*((volatile unsigned long *)0x7F008080))
+#define GPEDAT           (*((volatile unsigned long *)0x7F008084))
+/* LCD backlight */
+#define GPFCON           (*((volatile unsigned long *)0x7F0080A0))
+#define GPFDAT           (*((volatile unsigned long *)0x7F0080A4))
+
+#define RED 0
+#define GREEN 1
+#define BLUE 2
+#define TRANSP 3
+
+struct s3cfb_info {
+	void __iomem *base;
+	unsigned memory_size;
+	struct fb_info info;
+	struct device_d *hw_dev;
+	int passive_display;
+	void (*enable)(int enable);
+};
+
+/* the RGB565 true colour mode */
+static const struct fb_bitfield def_rgb565[] = {
+	[RED] = {
+		.offset = 11,
+		.length = 5,
+	},
+	[GREEN] = {
+		.offset = 5,
+		.length = 6,
+	},
+	[BLUE] = {
+		.offset = 0,
+		.length = 5,
+	},
+	[TRANSP] = {	/* no support for transparency */
+		.length = 0,
+	}
+};
+
+/* the RGB888 true colour mode */
+static const struct fb_bitfield def_rgb888[] = {
+	[RED] = {
+		.offset = 16,
+		.length = 8,
+	},
+	[GREEN] = {
+		.offset = 8,
+		.length = 8,
+	},
+	[BLUE] = {
+		.offset = 0,
+		.length = 8,
+	},
+	[TRANSP] = {	/* no support for transparency */
+		.length = 0,
+	}
+};
+
+/**
+ * @param fb_info Framebuffer information
+ */
+static void s3cfb_enable_controller(struct fb_info *fb_info)
+{
+	struct s3cfb_info *fbi = fb_info->priv;
+	uint32_t con0;
+
+	con0 = readl(fbi->base + VIDCON0);
+
+	con0 |= ENVID;
+	con0 |= ENVID_F;
+
+	writel(con0, fbi->base + VIDCON0);
+
+	if (fbi->enable)
+		fbi->enable(1);
+}
+
+/**
+ * @param fb_info Framebuffer information
+ */
+static void s3cfb_disable_controller(struct fb_info *fb_info)
+{
+	struct s3cfb_info *fbi = fb_info->priv;
+	uint32_t con0;
+
+	if (fbi->enable)
+		fbi->enable(0);
+
+	con0 = readl(fbi->base + VIDCON0);
+
+	con0 &= ~ENVID;
+	con0 &= ~ENVID_F;
+
+	writel(con0, fbi->base + VIDCON0);
+}
+
+/**
+ * Prepare the video hardware for a specified video mode
+ * @param fb_info Framebuffer information
+ * @return 0 on success
+ */
+static int s3cfb_activate_var(struct fb_info *fb_info)
+{
+	struct s3cfb_info *fbi = fb_info->priv;
+	struct fb_videomode *mode = fb_info->mode;
+	unsigned size, hclk, div;
+	uint32_t con0, con1, con2;
+	uint32_t tmp;
+
+	if (fbi->passive_display != 0) {
+		dev_err(fbi->hw_dev, "Passive displays are currently not supported\n");
+		return -EINVAL;
+	}
+
+	/* GPIO for LCD */
+	GPICON = 0xAAAAAAAA;
+	GPJCON = 0xAAAAAAAA;
+
+	/* LCD on */
+	GPECON &= ~(0xf);
+	GPECON |= (0x1);
+	GPEDAT |= 1;
+	/* backlight on*/
+	GPFCON &= ~(0x3 << 30);
+	GPFCON |= (1 << 30);
+	GPFDAT |= (1 << 15);
+
+	/* RGB I/F style */
+	SPCON &= ~(0x3 << 0);
+	SPCON |= 0x1;
+
+	/* normal mode(not bypass mode) */
+	MIFPCON &= ~(1 << 3);
+
+	/*
+	 * we need at least this amount of memory for the framebuffer
+	 */
+	/*
+	 * \NOTE: even 24bit_per_pix, we need 32bit_pre_pixel, but for barebox,
+	 * only 8/16/32, no 24bit mode, so we can just >> 3
+	 */
+	size = mode->xres * mode->yres * (fb_info->bits_per_pixel >> 3);
+	if (fbi->memory_size != size || fb_info->screen_base == NULL) {
+		if (fb_info->screen_base)
+			free(fb_info->screen_base);
+		fbi->memory_size = 0;
+
+		fb_info->screen_base = malloc(size);
+		if (! fb_info->screen_base)
+			return -ENOMEM;
+		memset(fb_info->screen_base, 0, size);
+		fbi->memory_size = size;
+	}
+
+	/* ensure video output is _off_ */
+	//writel(0x00000000, fbi->base + VIDCON0);
+
+	hclk = s3c_get_hclk();	/* hclk in Hz */
+	div = hclk / mode->pixclock;
+	if (div < 3)
+		div  = 3;
+	/* pixel clock is: (hclk) / (div + 1) */
+	div -= 1;
+
+	con0 = CLKDIR | CLKVAL_F(div) | ENVID | ENVID_F;
+	writel(con0, fbi->base + VIDCON0);
+
+	switch (fb_info->bits_per_pixel) {
+	case 16:
+		fb_info->red = def_rgb565[RED];
+		fb_info->green = def_rgb565[GREEN];
+		fb_info->blue = def_rgb565[BLUE];
+		fb_info->transp =  def_rgb565[TRANSP];
+		break;
+	case 32:
+		fb_info->red = def_rgb888[RED];
+		fb_info->green = def_rgb888[GREEN];
+		fb_info->blue = def_rgb888[BLUE];
+		fb_info->transp =  def_rgb888[TRANSP];
+		break;
+	default:
+		dev_err(fbi->hw_dev, "Invalid bits per pixel value: %u\n", fb_info->bits_per_pixel);
+		return -EINVAL;
+	}
+
+	con1 = IVCLK | IHSYNC | IVSYNC;
+	writel(con1, fbi->base + VIDCON1);
+
+	con0 = VBPD(mode->upper_margin - 1)
+		| VFPD(mode->lower_margin - 1)
+		| VSPW(mode->vsync_len - 1);
+	writel(con0, fbi->base + VIDTCON0);
+
+	con1 = HBPD(mode->left_margin - 1)
+		| HFPD(mode->right_margin - 1)
+		| HSPW(mode->hsync_len - 1);
+	writel(con1, fbi->base + VIDTCON1);
+
+	con2 = LINEVAL(mode->yres - 1) | HOZVAL(mode->xres - 1);
+	writel(con2, fbi->base + VIDTCON2);
+
+	tmp = readl(fbi->base + WINCON0);
+	tmp &= ~BPPMODE_F(0xf);
+	switch (fb_info->bits_per_pixel) {
+	case 16:/* RGB565 */
+		tmp |= BPPMODE_F(0x5);
+		break;
+	case 32:
+		tmp |= BPPMODE_F(0xB);
+		break;
+	}
+	tmp |= ENWIN_F;
+	writel(tmp, fbi->base + WINCON0);
+
+	con0 = LEFTTOPX_F(0) | LEFTTOPY_F(0);
+	writel(con0, fbi->base + VIDOSD0A);
+
+	con0 = RIGHTBOTX_F(mode->xres - 1) | RIGHTBOTY_F(mode->yres - 1);
+	writel(con0, fbi->base + VIDOSD0B);
+
+	con0 = mode->xres * mode->yres;
+	writel(con0, fbi->base + VIDOSD0C);
+
+
+	/* frame buffer start addr */
+	writel((unsigned long)(fb_info->screen_base), fbi->base + VIDW00ADD0B0);
+
+	/* frame buffer size */
+	writel(fbi->memory_size, fbi->base + VIDW00ADD1B0);
+
+	return 0;
+}
+
+/*
+ * There is only one video hardware instance available.
+ * It makes no sense to dynamically allocate this data
+ */
+static struct fb_ops s3cfb_ops = {
+	.fb_activate_var = s3cfb_activate_var,
+	.fb_enable = s3cfb_enable_controller,
+	.fb_disable = s3cfb_disable_controller,
+};
+
+static struct s3cfb_info fbi = {
+	.info = {
+		.fbops = &s3cfb_ops,
+	},
+};
+
+static int s3cfb_probe(struct device_d *hw_dev)
+{
+	struct s3c_fb_platform_data *pdata = hw_dev->platform_data;
+	int ret;
+
+	if (! pdata)
+		return -ENODEV;
+
+	fbi.base = dev_request_mem_region(hw_dev, 0);
+
+	/* just init */
+	fbi.info.priv = &fbi;
+
+	/* add runtime hardware info */
+	fbi.hw_dev = hw_dev;
+	hw_dev->priv = &fbi;
+
+	/* add runtime video info */
+	fbi.info.modes.modes = pdata->mode_list;
+	fbi.info.modes.num_modes = pdata->mode_cnt;
+
+	fbi.info.mode = &fbi.info.modes.modes[0];
+	fbi.info.xres = fbi.info.mode->xres;
+	fbi.info.yres = fbi.info.mode->yres;
+	if (pdata->bits_per_pixel)
+		fbi.info.bits_per_pixel = pdata->bits_per_pixel;
+	else
+		fbi.info.bits_per_pixel = 16;
+	fbi.passive_display = pdata->passive_display;
+	fbi.enable = pdata->enable;
+
+	ret = register_framebuffer(&fbi.info);
+	if (ret != 0) {
+		dev_err(hw_dev, "Failed to register framebuffer\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static struct driver_d s3cfb_driver = {
+	.name	= "s3c_fb",
+	.probe	= s3cfb_probe,
+};
+device_platform_driver(s3cfb_driver);
+
Index: barebox-2014.10.0/drivers/video/Kconfig
===================================================================
--- barebox-2014.10.0.orig/drivers/video/Kconfig
+++ barebox-2014.10.0/drivers/video/Kconfig
@@ -45,6 +45,12 @@ config DRIVER_VIDEO_S3C24XX
 	help
 	  Add support for the S3C244x LCD controller.
 
+config DRIVER_VIDEO_S3C64XX
+	bool "S3C64xx framebuffer driver"
+	depends on ARCH_S3C64xx
+	help
+	  Add support for the S3C64xx LCD controller.
+
 config DRIVER_VIDEO_OMAP
 	bool "OMAP framebuffer driver"
 	depends on ARCH_OMAP4
Index: barebox-2014.10.0/drivers/video/Makefile
===================================================================
--- barebox-2014.10.0.orig/drivers/video/Makefile
+++ barebox-2014.10.0/drivers/video/Makefile
@@ -8,6 +8,7 @@ obj-$(CONFIG_DRIVER_VIDEO_STM) += stm.o
 obj-$(CONFIG_DRIVER_VIDEO_IMX) += imx.o
 obj-$(CONFIG_DRIVER_VIDEO_IMX_IPU) += imx-ipu-fb.o
 obj-$(CONFIG_DRIVER_VIDEO_S3C24XX) += s3c24xx.o
+obj-$(CONFIG_DRIVER_VIDEO_S3C64XX) += s3c64xx.o
 obj-$(CONFIG_DRIVER_VIDEO_PXA) += pxa.o
 obj-$(CONFIG_DRIVER_VIDEO_SDL) += sdl.o
 obj-$(CONFIG_DRIVER_VIDEO_OMAP) += omap.o
Index: barebox-2014.10.0/arch/arm/mach-samsung/include/mach/s3c64xx-iomap.h
===================================================================
--- barebox-2014.10.0.orig/arch/arm/mach-samsung/include/mach/s3c64xx-iomap.h
+++ barebox-2014.10.0/arch/arm/mach-samsung/include/mach/s3c64xx-iomap.h
@@ -15,6 +15,7 @@
 /* S3C64xx device base addresses */
 #define S3C_SROM_SFR		0x70000000
 #define S3C_NAND_BASE		0x70200000
+#define S3C_VID_BASE		0x77100000
 #define S3C_SDI0_BASE		0x7c200000
 #define S3C_SDI0_SIZE		0x100
 #define S3C_SDI1_BASE		0x7c300000
Index: barebox-2014.10.0/arch/arm/configs/njjl_arm11plf_defconfig
===================================================================
--- /dev/null
+++ barebox-2014.10.0/arch/arm/configs/njjl_arm11plf_defconfig
@@ -0,0 +1,85 @@
+CONFIG_TEXT_BASE=0x57f80000
+CONFIG_BAREBOX_MAX_IMAGE_SIZE=0x80000
+CONFIG_BAREBOX_MAX_BARE_INIT_SIZE=0x2000
+CONFIG_ARCH_S3C64xx=y
+CONFIG_MACH_ARM11PLF=y
+CONFIG_S3C_LOWLEVEL_INIT=y
+CONFIG_S3C_PLL_INIT=y
+CONFIG_S3C_SDRAM_INIT=y
+CONFIG_S3C_NAND_BOOT=y
+CONFIG_S3C_MMC_BOOT=y
+CONFIG_AEABI=y
+CONFIG_ARM_OPTIMZED_STRING_FUNCTIONS=y
+CONFIG_BROKEN=y
+CONFIG_PROMPT="arm11plf:"
+CONFIG_LONGHELP=y
+CONFIG_GLOB=y
+CONFIG_CMDLINE_EDITING=y
+CONFIG_AUTO_COMPLETE=y
+CONFIG_PARTITION=y
+CONFIG_PARTITION_DISK=y
+CONFIG_DEFAULT_ENVIRONMENT_GENERIC_NEW=y
+CONFIG_DEFAULT_ENVIRONMENT_PATH="arch/arm/boards/njjl-arm11plf/env"
+CONFIG_DEBUG_INFO=y
+CONFIG_CMD_ECHO_E=y
+CONFIG_CMD_FLASH=y
+CONFIG_CMD_EDIT=y
+CONFIG_CMD_SLEEP=y
+CONFIG_CMD_LOADENV=y
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_EXPORT=y
+CONFIG_CMD_PRINTENV=y
+CONFIG_CMD_READLINE=y
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_MTEST=y
+CONFIG_CMD_BOOTM_SHOW_TYPE=y
+CONFIG_CMD_BOOTM_VERBOSE=y
+CONFIG_CMD_BOOTM_INITRD=y
+CONFIG_CMD_BOOTM_OFTREE=y
+CONFIG_CMD_BOOTM_OFTREE_UIMAGE=y
+CONFIG_CMD_BOOTM_AIMAGE=y
+CONFIG_CMD_BOOTU=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_LOADS=y
+CONFIG_CMD_LOADY=y
+CONFIG_CMD_RESET=y
+CONFIG_CMD_SAVES=y
+CONFIG_CMD_UIMAGE=y
+CONFIG_CMD_TIMEOUT=y
+CONFIG_CMD_PARTITION=y
+CONFIG_CMD_MAGICVAR=y
+CONFIG_CMD_MAGICVAR_HELP=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_UNCOMPRESS=y
+CONFIG_CMD_TFTP=y
+CONFIG_CMD_MD5SUM=y
+CONFIG_CMD_SPLASH=y
+CONFIG_CMD_NANDTEST=y
+CONFIG_CMD_2048=y
+CONFIG_NET=y
+CONFIG_NET_DHCP=y
+CONFIG_NET_PING=y
+CONFIG_NET_TFTP=y
+CONFIG_DRIVER_NET_DM9K=y
+CONFIG_ZLIB=y
+CONFIG_BZLIB=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_VIDEO=y
+CONFIG_DRIVER_VIDEO_S3C64XX=y
+CONFIG_MTD_UBI=y
+CONFIG_FS_CRAMFS=y
+CONFIG_FS_EXT4=y
+CONFIG_FS_TFTP=y
+CONFIG_FS_FAT=y
+CONFIG_FS_FAT_WRITE=y
+CONFIG_FS_FAT_LFN=y
+CONFIG_FS_UBIFS=y
+CONFIG_FS_UBIFS_COMPRESSION_LZO=y
+CONFIG_FS_UBIFS_COMPRESSION_ZLIB=y
+CONFIG_FS_UIMAGEFS=y
+CONFIG_MCI=y
+CONFIG_MCI_MMC_BOOT_PARTITIONS=y
+CONFIG_MCI_S3C64XX=y
+CONFIG_BAREBOXENV_TARGET=y
Index: barebox-2014.10.0/arch/arm/boards/njjl-arm11plf/Makefile
===================================================================
--- /dev/null
+++ barebox-2014.10.0/arch/arm/boards/njjl-arm11plf/Makefile
@@ -0,0 +1,3 @@
+obj-y += development-board.o lowlevel_init.o
+pbl-y += lowlevel_init.o
+lwl-y += lowlevel_init.o
Index: barebox-2014.10.0/arch/arm/boards/njjl-arm11plf/config.h
===================================================================
--- /dev/null
+++ barebox-2014.10.0/arch/arm/boards/njjl-arm11plf/config.h
@@ -0,0 +1,37 @@
+/* Nanjing Jilong Arm11plf specific global settings */
+
+#ifndef _ARM11PLF_CONFIG_H_
+# define _ARM11PLF_CONFIG_H_
+
+#define S3C64XX_CLOCK_REFERENCE 12000000
+
+#define BOARD_SPECIFIC_CLKDIVN   ( \
+		(0  << 0)   |   \
+                (1 << 4)   |   \
+		(1 << 8)   |   \
+		(1 << 9) |   \
+		(3 << 12))
+
+#define BOARD_SPECIFIC_APLL     ((1 << 31) | (266 << 16) | (3 << 8) | (1 << 0))
+#define BOARD_SPECIFIC_MPLL     ((1 << 31) | (266 << 16) | (3 << 8) | (1 << 0))
+
+#define BOARD_SPECIFIC_HCLK	133000000
+#define NS_TO_HCYCLE(ns)	(ns/(1000000000/BOARD_SPECIFIC_HCLK)+1)
+
+/*
+ * Flash access timings
+ */
+#define ARM11PLF_TACLS NS_TO_HCYCLE(25)
+#define ARM11PLF_TWRPH0 (NS_TO_HCYCLE(55) - 1)
+#define ARM11PLF_TWRPH1 (NS_TO_HCYCLE(40) - 1)
+
+/* needed in the generic NAND boot code only */
+#ifdef CONFIG_S3C_NAND_BOOT
+# define BOARD_DEFAULT_NAND_TIMING \
+	CALC_NFCONF_TIMING(ARM11PLF_TACLS, ARM11PLF_TWRPH0, ARM11PLF_TWRPH1)
+
+#define BOARD_SPECIFIC_NAND_PAGESIZE 2048
+#define BOARD_SPECIFIC_NAND_ADDRCYCLE 5
+#endif
+
+#endif /* _ARM11PLF_CONFIG_H_ */
Index: barebox-2014.10.0/arch/arm/boards/njjl-arm11plf/development-board.c
===================================================================
--- /dev/null
+++ barebox-2014.10.0/arch/arm/boards/njjl-arm11plf/development-board.c
@@ -0,0 +1,373 @@
+/*
+ * Copyright (C) 2012 Juergen Beisert
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * The Nanjing Jilong's Arm11plf evaluation board comes with all connectors and
+ * devices to make the Arm11plf CPU card work. This includes:
+ *
+ * - the DM9000 network controller
+ * - USB/MCI connectors
+ * - display connector
+ *
+ */
+#include <common.h>
+#include <bootsource.h>
+#include <environment.h>
+#include <driver.h>
+#include <init.h>
+#include <gpio.h>
+#include <dm9000.h>
+#include <fb.h>
+#include <io.h>
+#include <asm/armlinux.h>
+#include <generated/mach-types.h>
+#include <mach/iomux.h>
+#include <mach/s3c24xx-nand.h>
+#include <mach/devices-s3c64xx.h>
+#include <mach/s3c-generic.h>
+#include <mach/s3c-iomap.h>
+#include <mach/s3c24xx-fb.h>
+
+#define SYS_PA_FPGA 0x30000000
+#define FPGA_ADDR(x) (SYS_PA_FPGA + (x))
+
+/*
+ * dm9000 network controller onboard
+ * Connected to CS line 1 and interrupt line EINT7,
+ * data width is 16 bit
+ * Area 1: Offset 0x300...0x301
+ * Area 2: Offset 0x304...0x305
+ */
+static struct dm9000_platform_data dm9000_data = {
+	.srom = 0,	/* no serial ROM for the ethernet address */
+};
+
+static const struct s3c6410_chipselect dm900_cs = {
+	.adr_setup_t = 0,
+	.access_setup_t = 0,
+	.access_t = 20,
+	.cs_hold_t = 3,
+	.adr_hold_t = 20, /* CS must be de-asserted for at least 20 ns */
+	.width = 16,
+};
+
+static void arm11plfevk_setup_dm9000_cs(void)
+{
+	s3c6410_setup_chipselect(1, &dm900_cs);
+}
+
+/**
+ * nand
+ */
+static struct s3c24x0_nand_platform_data arm11plf_nand_info = {
+	.nand_timing = BOARD_DEFAULT_NAND_TIMING,
+	.flash_bbt = 0,	/* same as the kernel */
+};
+
+static struct resource arm11plf_nand_res = {
+	.start = S3C_NAND_BASE,
+	.end = S3C_NAND_BASE + 0x80,
+	.flags = IORESOURCE_MEM,
+};
+
+static struct device_d arm11plf_nand_device = {
+	.name = "s3c6400-nand",
+	.resource = &arm11plf_nand_res,
+	.num_resources = 1,
+	.platform_data = &arm11plf_nand_info,
+};
+
+
+/**
+ * lcd
+ */
+static struct fb_videomode arm11plf_fb_modes[] = {
+	[0] = {
+		.name		= "N35",
+		/* 3.5" 320x240 */
+		.left_margin    = 65,
+		.right_margin   = 23,
+		.upper_margin   = 3,
+		.lower_margin   = 20,
+		.hsync_len      = 5,
+		.vsync_len      = 10,
+		.xres           = 320,
+		.yres           = 240,
+		.pixclock	= 11000000, /* in Hz */
+		.display_flags	= 0,
+	},
+};
+
+static void arm11plf_lcd_power_set(int enable)
+{
+       volatile void __iomem *p = (volatile void __iomem *)FPGA_ADDR(0x40);
+       uint16_t val;
+
+       val = __raw_readw(p);
+       if (enable) {
+               val |= BIT(5);
+       }
+       else {
+               val &= ~BIT(5);
+       }
+       __raw_writew(val, p);
+}
+
+static struct s3c_fb_platform_data arm11plf_fb_data = {
+	.mode_list		= arm11plf_fb_modes,
+	.mode_cnt		= sizeof(arm11plf_fb_modes) / sizeof(struct fb_videomode),
+	.bits_per_pixel		= 32,
+	.passive_display	= 0,
+	.enable			= arm11plf_lcd_power_set,
+};
+
+static struct resource arm11plf_lcd_res = {
+	.start = S3C_VID_BASE,
+	.end = S3C_VID_BASE + 0x348,
+	.flags = IORESOURCE_MEM,
+};
+
+static struct device_d arm11plf_device_lcd = {
+	.name = "s3c_fb",
+	.resource = &arm11plf_lcd_res,
+	.num_resources = 1,
+	.id = DEVICE_ID_DYNAMIC,
+	.platform_data = &arm11plf_fb_data,
+};
+
+static struct resource arm11plf_mmc_res[3] = {
+	[0] = {
+		.start = S3C_SDI0_BASE,
+		.end = S3C_SDI0_BASE + S3C_SDI0_SIZE,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = S3C_SDI1_BASE,
+		.end = S3C_SDI1_BASE + S3C_SDI0_SIZE,
+		.flags = IORESOURCE_MEM,
+	},
+	[2] = {
+		.start = S3C_SDI2_BASE,
+		.end = S3C_SDI2_BASE + S3C_SDI0_SIZE,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+static struct device_d arm11plf_mmc0 = {
+	.name = "s3c-sdhci",
+	.resource = &arm11plf_mmc_res[0],
+	.num_resources = 1,
+	.id = DEVICE_ID_DYNAMIC,
+};
+
+#if 0
+static struct device_d arm11plf_mmc1 = {
+	.name = "s3c-sdhci",
+	.resource = &arm11plf_mmc_res[1],
+	.num_resources = 1,
+	.id = DEVICE_ID_DYNAMIC,
+};
+
+static struct device_d arm11plf_mmc2 = {
+	.name = "s3c-sdhci",
+	.resource = &arm11plf_mmc_res[2],
+	.num_resources = 1,
+	.id = DEVICE_ID_DYNAMIC,
+};
+#endif
+
+/**
+ * custom init
+ */
+static void arm11plf_custom_init(void)
+{
+	uint32_t tmp;
+	/* set the LCD type */
+	tmp = __raw_readl(S3C_GPIO_BASE + 0x1A0);	/// SPCON
+	tmp &= ~0x3;	// S3C64XX_SPCON_LCD_SEL_MASK
+	tmp |= 0x1;	// S3C64XX_SPCON_LCD_SEL_RGB;
+	__raw_writel(tmp, (S3C_GPIO_BASE + 0x1A0));
+
+	/* remove the LCD bypass */
+	tmp = __raw_readl(0x7410800C);	// S3C64XX_MODEM_MIFPCON
+	tmp &= ~(0x1 << 3);		// MIFPCON_LCD_BYPASS
+	__raw_writel(tmp, 0x7410800C);
+
+	//change fpga's bus
+	tmp = __raw_readl(S3C_SROM_BW);
+	tmp |= 0x00010000; //for bank4, 16bits width
+	__raw_writel(tmp, S3C_SROM_BW);
+
+	tmp = __raw_readl(S3C_SROM_SFR + 0x14);	// S3C64XX_SROM_BC4
+	tmp |= 0x0f00f000; //for CS max clock
+	__raw_writel(tmp, (S3C_SROM_SFR + 0x14));
+
+	/// \note the gpio o ports must be default value, for accessing FPGA registers.
+
+       /// close camera
+       __raw_writew(BIT(2), FPGA_ADDR(0x10));
+
+       udelay(1000);
+
+       /// open lcd
+       __raw_writew(0x2E8, FPGA_ADDR(0x56));
+       __raw_writew(0x1A0, FPGA_ADDR(0x58));
+
+       __raw_writew(BIT(5), FPGA_ADDR(0x40));
+}
+
+/* all arm11plf platforn devices */
+static struct device_d *arm11plf_platform_devices[] = {
+	&arm11plf_nand_device,
+	&arm11plf_device_lcd,
+	&arm11plf_mmc0,
+};
+
+/**
+ * pin
+ */
+static const unsigned arm11plfevk_pin_usage[] = {
+	/// \note GPO and GPP use the default value 0xAAAAAAAA, used accessing FPGA register
+
+	GPF13_GPIO  | GPIO_OUT | GPIO_VAL(0), /* OTG power supply, 0 = off */
+
+	/* UART0 */
+	GPA0_RXD0 | ENABLE_PU,
+	GPA1_TXD0,
+	GPA2_GPIO | GPIO_IN | ENABLE_PU, /* CTS not connected */
+	GPA3_GPIO | GPIO_IN | ENABLE_PU, /* RTS not connected */
+	/* UART1 (V24) */
+	GPA4_RXD1 | ENABLE_PU,
+	GPA5_TXD1,
+	GPA6_NCTS1 | ENABLE_PU,
+	GPA7_NRTS1,
+	/* UART2 (V24) */
+	GPB0_RXD2 | ENABLE_PU,
+	GPB1_TXD2,
+	/* UART3 (spare, 3,3 V TTL level only) */
+	GPB2_RXD3 | ENABLE_PU,
+	GPB3_TXD3,
+	/* mmc0 */
+	GPG0_MMC0_CLK,
+	GPG1_MMC0_CMD,
+	GPG2_MMC0_DAT0,
+	GPG3_MMC0_DAT1,
+	GPG4_MMC0_DAT2,
+	GPG5_MMC0_DAT3,
+	GPG6_MMC0_NCD,
+};
+
+static int arm11plf_mem_init(void)
+{
+	arm_add_mem_device("ram0", S3C_SDRAM_BASE, s3c6410_get_memory_size());
+
+	return 0;
+}
+mem_initcall(arm11plf_mem_init);
+
+static int arm11plfevk_devices_init(void)
+{
+	int i;
+
+	/* ----------- configure the access to the outer space ---------- */
+	for (i = 0; i < ARRAY_SIZE(arm11plfevk_pin_usage); i++)
+		s3c_gpio_mode(arm11plfevk_pin_usage[i]);
+
+	arm11plf_custom_init();
+
+	arm11plfevk_setup_dm9000_cs();
+	add_dm9000_device(0, S3C_CS1_BASE + 0x300, S3C_CS1_BASE + 0x304,
+				IORESOURCE_MEM_16BIT, &dm9000_data);
+
+	/* register all platform devices */
+	for(i = 0; i < ARRAY_SIZE(arm11plf_platform_devices); i++)
+		platform_device_register(arm11plf_platform_devices[i]);
+
+	armlinux_set_bootparams((void *)S3C_SDRAM_BASE + 0x100);
+	armlinux_set_architecture(MACH_TYPE_ARM11PLF);
+
+	return 0;
+}
+device_initcall(arm11plfevk_devices_init);
+
+static int arm11plfevk_console_init(void)
+{
+	/* note: UART0 has no RTS/CTS connected */
+	s3c_gpio_mode(GPA0_RXD0 | ENABLE_PU);
+	s3c_gpio_mode(GPA1_TXD0);
+
+	s3c64xx_add_uart1();
+
+	return 0;
+}
+console_initcall(arm11plfevk_console_init);
+
+static int arm11plfevk_get_adc1(void)
+{
+	int v;
+	char tmp[10];
+
+	//delay  40000
+	writel(40000, 0x7e00b008);
+	//adc1 12bits 49 prescal
+	writel(0x14c49, 0x7e00b000);
+	//wait complete
+	udelay(10*1000); // 10ms ok
+	//read it
+	v = readl(0x7e00b00c) & 0xFFF;
+	//clear adc int
+	writel(1, 0x7e00b018);
+
+	sprintf(tmp,"%d",v);
+	setenv("adc1",tmp);
+	export("adc1");
+
+	return 0;
+}
+postcore_initcall(arm11plfevk_get_adc1);
+
+static int arm11plfevk_init(void)
+{
+	const uint32_t reg_val = readl(0x7E00F12C);
+
+	enum bootsource src = BOOTSOURCE_UNKNOWN;
+	switch (reg_val & 0xE0) {
+	case 0x80:
+		src = BOOTSOURCE_NAND;
+		break;
+	case 0x60:
+		src = BOOTSOURCE_MMC;
+		break;
+	default:
+		src = BOOTSOURCE_UNKNOWN;
+	}
+
+	bootsource_set(src);
+	bootsource_set_instance(0);
+
+	return 0;
+}
+postcore_initcall(arm11plfevk_init);
+
+static int arm11plfevk_beep_on(void)
+{
+	s3c_gpio_mode(GPH1_GPIO | GPIO_OUT | GPIO_VAL(1));
+	return 0;
+}
+pure_initcall(arm11plfevk_beep_on);
+
+static int arm11plfevk_beep_off(void)
+{
+	s3c_gpio_mode(GPH1_GPIO | GPIO_OUT | GPIO_VAL(0));
+	return 0;
+}
+late_initcall(arm11plfevk_beep_off);
Index: barebox-2014.10.0/arch/arm/boards/njjl-arm11plf/env/config
===================================================================
--- /dev/null
+++ barebox-2014.10.0/arch/arm/boards/njjl-arm11plf/env/config
@@ -0,0 +1,4 @@
+#!/bin/sh
+MBVer=
+prd_boot_sel=
+hw_cfg=
Index: barebox-2014.10.0/arch/arm/tools/mach-types
===================================================================
--- barebox-2014.10.0.orig/arch/arm/tools/mach-types
+++ barebox-2014.10.0/arch/arm/tools/mach-types
@@ -1619,6 +1619,7 @@ inc20otter		MACH_INC20OTTER		INC20OTTER
 at91sam9g20ek		MACH_AT91SAM9G20EK	AT91SAM9G20EK		1624
 sc_ge2			MACH_STORCENTER		STORCENTER		1625
 smdk6410		MACH_SMDK6410		SMDK6410		1626
+arm11plf		MACH_ARM11PLF		ARM11PLF		1626
 u300			MACH_U300		U300			1627
 u500			MACH_U500		U500			1628
 ds9260			MACH_DS9260		DS9260			1629
Index: barebox-2014.10.0/arch/arm/mach-samsung/Kconfig
===================================================================
--- barebox-2014.10.0.orig/arch/arm/mach-samsung/Kconfig
+++ barebox-2014.10.0/arch/arm/mach-samsung/Kconfig
@@ -8,6 +8,7 @@ config ARCH_TEXT_BASE
 	default 0x31fc0000 if MACH_MINI2440
 	default 0x57fc0000 if MACH_MINI6410
 	default 0x57fc0000 if MACH_TINY6410
+	default 0x57fc0000 if MACH_ARM11PLF
 	default 0x31fc0000 if MACH_A9M2440
 	default 0x31fc0000 if MACH_A9M2410
 	default 0x23e00000 if MACH_TINY210
@@ -103,6 +104,15 @@ config MACH_TINY6410
 	  Say Y here if you are using FriendlyARM Tiny6410 CPU card equipped
 	  with a Samsung S3C6410 Processor
 
+config MACH_ARM11PLF
+	bool "arm11 platform"
+	select CPU_S3C6410
+	select HAS_DM9000
+	select HAVE_DEFAULT_ENVIRONMENT_NEW
+	help
+	  Say Y here if you are using Nanjing Jilong Arm11plf CPU card equipped
+	  with a Samsung S3C6410 Processor
+
 endchoice
 
 menu "Board specific settings"
@@ -158,14 +168,23 @@ config S3C_SDRAM_INIT
 config S3C_NAND_BOOT
 	bool
 	prompt "Booting from NAND"
-	depends on ARCH_S3C24xx
+	depends on (ARCH_S3C24xx || ARCH_S3C64xx)
 	select MTD
 	select NAND
-	select NAND_S3C24XX
+	select NAND_S3C24XX if ARCH_S3C24xx
+	select NAND_S3C64XX if ARCH_S3C64xx
 	help
 	  Add generic support to boot from NAND flash. Image loading will be
 	  skipped if the code is running from NOR or already from SDRAM.
 
+config S3C_MMC_BOOT
+	bool
+	prompt "Booting from MMC/SD card"
+	depends on (ARCH_S3C24xx || ARCH_S3C64xx)
+	help
+	  Add generic support to boot from MMC/SD card. Image loading will be
+	  skipped if the code is running from NOR or already from SDRAM.
+
 endmenu
 
 endif
Index: barebox-2014.10.0/arch/arm/mach-samsung/Makefile
===================================================================
--- barebox-2014.10.0.orig/arch/arm/mach-samsung/Makefile
+++ barebox-2014.10.0/arch/arm/mach-samsung/Makefile
@@ -1,6 +1,7 @@
 obj-y += s3c-timer.o generic.o
 obj-$(CONFIG_RESET_SOURCE) += reset_source.o
 obj-lowlevel-$(CONFIG_ARCH_S3C24xx) += lowlevel-s3c24x0.o
+obj-lowlevel-$(CONFIG_ARCH_S3C64xx) += lowlevel-s3c64xx.o
 obj-lowlevel-$(CONFIG_ARCH_S5PCxx) += lowlevel-s5pcxx.o
 pbl-$(CONFIG_ARCH_S3C24xx) += lowlevel-s3c24x0.o
 pbl-$(CONFIG_ARCH_S5PCxx) += lowlevel-s5pcxx.o
@@ -9,3 +10,5 @@ obj-$(CONFIG_ARCH_S3C64xx) += gpio-s3c64
 obj-$(CONFIG_ARCH_S5PCxx) += gpio-s5pcxx.o clocks-s5pcxx.o mem-s5pcxx.o
 pbl-$(CONFIG_ARCH_S5PCxx) += mem-s5pcxx.o
 obj-$(CONFIG_S3C_LOWLEVEL_INIT) += $(obj-lowlevel-y)
+obj-$(CONFIG_S3C_MMC_BOOT) += mmc_boot.o
+pbl-$(CONFIG_S3C_MMC_BOOT) += mmc_boot.o
Index: barebox-2014.10.0/arch/arm/mach-samsung/include/mach/s3c64xx-clocks.h
===================================================================
--- barebox-2014.10.0.orig/arch/arm/mach-samsung/include/mach/s3c64xx-clocks.h
+++ barebox-2014.10.0/arch/arm/mach-samsung/include/mach/s3c64xx-clocks.h
@@ -12,6 +12,9 @@
  * GNU General Public License for more details.
  */
 
+#define S3C_APLL_LOCK  (S3C_CLOCK_POWER_BASE)
+#define S3C_MPLL_LOCK  (S3C_CLOCK_POWER_BASE + 0x04)
+
 #define S3C_EPLL_LOCK  (S3C_CLOCK_POWER_BASE + 0x08)
 # define S3C_EPLL_LOCK_PLL_LOCKTIME(x) ((x) & 0xffff)
 #define S3C_APLLCON (S3C_CLOCK_POWER_BASE + 0x0c)
Index: barebox-2014.10.0/arch/arm/mach-samsung/lowlevel-s3c64xx.S
===================================================================
--- /dev/null
+++ barebox-2014.10.0/arch/arm/mach-samsung/lowlevel-s3c64xx.S
@@ -0,0 +1,426 @@
+/*
+ * (C) Copyright 2013
+ * Yi Qingliang <niqingliang2003@gamail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <config.h>
+#include <mach/s3c-iomap.h>
+
+	.section ".text_bare_init.s3c64xx_disable_wd","ax"
+
+/*
+ * Disable the watchdog, else it continues to bark
+ */
+.globl s3c64xx_disable_wd
+s3c64xx_disable_wd:
+
+	ldr r0, =S3C_WATCHDOG_BASE
+	mov r1, #0x0
+	str r1, [r0]
+	mov pc, lr
+
+/**
+@page dev_s3c64xx_wd_handling Watchdog handling
+
+The watchdog must be disabled very early, because if it resets the system
+it is still active and will continue to reset the system. So, call this
+routine very early in your board_init_lowlevel routine.
+*/
+
+/*
+ * S3C2410 PLL configuration
+ * -------------------------
+ *
+ * Basic frequency calculation
+ *
+ *            m * REFclk         s = SDIV
+ * PLLclk = ------------         p = PDIV + 2
+ *             p * 2^s           m = MDIV + 8
+ *
+ * After reset the PLL of the s3c2410 processor uses:
+ *
+ *         MPLL   UPLL
+ *  MDIV   0x5c   0x28
+ *  PDIV   0x08   0x08
+ *  SDIV   0x0    0x0
+ *
+ *            100 * 12MHz     1200MHz
+ * MPLLclk = ------------- = -------- = 120MHz
+ *             10 * 2^0         10
+ *
+ *            48 * 12MHz      576MHz
+ * UPLLclk = ------------- = -------- = 57,6MHz
+ *             10 * 2^0        10
+ *
+ * Note: Do not use "r10" here in this code
+ */
+
+#ifdef CONFIG_S3C_PLL_INIT
+
+	.section ".text_bare_init.s3c64xx_pll_init","ax"
+
+.globl s3c64xx_pll_init
+s3c64xx_pll_init:
+
+	ldr r0, =S3C_CLOCK_POWER_BASE
+
+	/* configure internal clock ratio */
+	ldr r1, =BOARD_SPECIFIC_CLKDIVN
+	str r1, [r0, #0x20]
+#if 0
+	/* enable all devices on this chip */
+	mov r1, #0xFFFFFFF0
+	str r1, [r0, #0x12]
+#endif
+
+	ldr r1, =0xFFFF
+	str r1, [r0, #0x0]
+	ldr r1, =0xFFFF
+	str r1, [r0, #0x4]
+
+	/*
+	 * Most of the time HDIVN is not 0, so we must use the
+	 * asynchronous bus mode (refer datasheet "Clock and Power Management")
+	 */
+	ldr r1, [r0, #0x900]
+	ldr r2, =(~0xC0)
+	and r1, r1, r2
+	str r1, [r0, #0x900]
+
+1:	ldr r1, [r0, #0x900]
+	and r1, r1, #0xF00
+	subs r1, r1, #0
+	bne 1b
+
+	/* configure APLL */
+	ldr r1, =BOARD_SPECIFIC_APLL
+	str r1, [r0, #0xC]
+
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	/* configure MPLL */
+	ldr r1, =BOARD_SPECIFIC_MPLL
+	str r1, [r0, #0x10]
+
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+#ifdef CONFIG_S3C_MMC_BOOT
+	/* configure EPLL */ /* it is used by mmc boot */
+	ldr r1, [r0, #0x14]
+	orr r1, r1, #0x80000000
+	str r1, [r0, #0x14]
+
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+#endif
+	/* configure clk src */
+	mov r1, #0x3
+	str r1, [r0, #0x1C]
+
+	mov pc, lr
+
+#endif
+
+/**
+@page dev_s3c24xx_pll_handling PLL clock handling
+
+To control the speed of your machine the PLLs must be reconfigured after reset.
+
+For example the S3C2410 CPU wakes up after reset at 120MHz main PLL speed,
+shared with all other system on chip components. Most of the time this
+configuration is to slow for the CPU and to fast for the other components.
+
+PLL reprogramming can be done in the machine specific manner very early when
+the CONFIG_S3C_PLL_INIT and CONFIG_MACH_HAS_LOWLEVEL_INIT symbols are
+defined. The board must provide a board_init_lowlevel() assembler function in
+this case and calling the s3c24x0_pll_init() assembler function.
+
+If the s3c24x0_pll_init() is called a few further symbols must be defined to
+setup the correct values for the machine.
+
+Define in the machine specific config.h the following symbols:
+
+- S3C24XX_CLOCK_REFERENCE with the frequency in Hz of your reference crystal.
+- BOARD_SPECIFIC_CLKDIVN with the value for the main clock ratio register (CLKDIVN)
+- BOARD_SPECIFIC_MPLL with the value for the main PLL setup register
+- BOARD_SPECIFIC_UPLL with the value for the USB PLL setup register
+
+@note Valid values for the PLL settings can be found in the CPU manual.
+
+@par Background: PLL frequency calculation for the S3C2410 CPU (both PLLs) and S3C2440 (UPLL only)
+
+@f[
+	f_{PLL} = \frac{m * f_{Ref}}{p * 2^s}
+@f]
+
+With m = MDIV + 8, p = PDIV + 2 and s = SDIV.
+
+@par Background: PLL frequency calculation for the S3C2440 CPU (MPLL only)
+
+@f[
+	f_{PLL} = \frac{2 * m * f_{Ref}}{p * 2^s}
+@f]
+
+With m = MDIV + 8, p = PDIV + 2 and s = SDIV.
+
+@note This routine can be used for the S3C2410 and the S3C2440 CPU.
+
+*/
+
+/* ----------------------------------------------------------------------- */
+
+#ifdef CONFIG_S3C_SDRAM_INIT
+
+	.section ".text_bare_init.s3c64xx_sdram_init","ax"
+
+	.globl s3c64xx_sdram_init
+s3c64xx_sdram_init:
+	/* */
+	ldr r0, =S3C_DRAMC
+
+	/* start configure */
+	ldr r1, =0x4
+	str r1, [r0, #0x4]
+
+	ldr r1, =NS_TO_HCYCLE(7800)
+	str r1, [r0, #0x10]
+
+	ldr r1, =(0x3 << 1)
+	str r1, [r0, #0x14]
+
+	ldr r1, =0x1
+	str r1, [r0, #0x18]
+
+	ldr r1, =0x2
+	str r1, [r0, #0x1C]
+
+	ldr r1, =NS_TO_HCYCLE(45)
+	str r1, [r0, #0x20]
+
+	ldr r1, =NS_TO_HCYCLE(68)
+	str r1, [r0, #0x24]
+
+	ldr r1, =(NS_TO_HCYCLE(23) | ((NS_TO_HCYCLE(23) - 3) << 3))
+	str r1, [r0, #0x28]
+
+	ldr r1, =(NS_TO_HCYCLE(80) | ((NS_TO_HCYCLE(80) - 3) << 5))
+	str r1, [r0, #0x2C]
+
+	ldr r1, =(NS_TO_HCYCLE(23) | ((NS_TO_HCYCLE(23) - 3) << 3))
+	str r1, [r0, #0x30]
+
+	ldr r1, =NS_TO_HCYCLE(15)
+	str r1, [r0, #0x34]
+
+	ldr r1, =NS_TO_HCYCLE(15)
+	str r1, [r0, #0x38]
+
+	ldr r1, =0x7
+	str r1, [r0, #0x3C]
+
+	ldr r1, =0x2
+	str r1, [r0, #0x40]
+
+	ldr r1, =NS_TO_HCYCLE(120)
+	str r1, [r0, #0x44]
+
+	ldr r1, =NS_TO_HCYCLE(120)
+	str r1, [r0, #0x48]
+
+	/* mem init */
+	ldr r1, =((2 << 15) | (2 << 3) | (2 << 0))
+	str r1, [r0, #0xC]
+	ldr r1, =((1 << 11) | (3 << 8) | (1 << 6) | (1 << 0))
+	str r1, [r0, #0x4C]
+
+	/** 128 M **/
+	ldr r1, =((1 << 16) | (0xFF << 8) | (0xF8))
+	str r1, [r0, #0x200]
+	ldr r1, =((1 << 16) | (0xFF << 8))
+	str r1, [r0, #0x204]
+
+	ldr r1, =0xC0000
+	str r1, [r0, #0x8]
+	ldr r1, =0x00000
+	str r1, [r0, #0x8]
+	ldr r1, =0x40000
+	str r1, [r0, #0x8]
+	ldr r1, =0x40000
+	str r1, [r0, #0x8]
+	ldr r1, =0xA0000
+	str r1, [r0, #0x8]
+	ldr r1, =0x80032
+	str r1, [r0, #0x8]
+
+	/* MEM_SYS_CFG */
+	ldr r2, =0x7E00F120
+	ldr r3, =0x0
+	str r3, [r2]
+
+	/* start go */
+	ldr r1, =0x0
+	str r1, [r0, #0x4]
+
+	/* wait ready */
+2:
+	ldr r1, [r0]
+	and r1, r1, #0x3
+	cmp r1, #0x1
+	bne 2b
+
+	mov pc, lr
+
+#endif
+
+/**
+@page dev_s3c24xx_sdram_handling SDRAM controller initialisation
+
+The SDRAM controller is very simple and its initialisation requires only a
+few steps. barebox provides a generic routine to do this step.
+
+Enable CONFIG_S3C_SDRAM_INIT and CONFIG_MACH_HAS_LOWLEVEL_INIT to be able
+to call the generic s3c24x0_sdram_init() assembler function from within the
+machine specific board_init_lowlevel() assembler function.
+
+To use the s3c24x0_sdram_init() assembler function a few symbols must be
+defined to setup correct values for the machine.
+
+Define in the machine specific config.h the following list of symbols:
+
+- BOARD_SPECIFIC_BWSCON with the values for SDRAM banks 6 and 7
+- BOARD_SPECIFIC_BANKCON6 with the value for the BANKCON6 register
+- BOARD_SPECIFIC_BANKCON7 with the value for the BANKCON7 register
+- BOARD_SPECIFIC_REFRESH with the value for the REFRESH register
+- BOARD_SPECIFIC_BANKSIZE with the value for the BANKSIZE register
+- BOARD_SPECIFIC_MRSRB6 with the value for the MRSRB6 register
+- BOARD_SPECIFIC_MRSRB7 with the value for the MRSRB7 register
+*/
+
+/* ----------------------------------------------------------------------- */
+
+#ifdef CONFIG_S3C_NAND_BOOT
+
+	.section ".text_bare_init.s3c64xx_nand_boot","ax"
+
+	.globl s3c64xx_nand_boot
+s3c64xx_nand_boot:
+#if 0
+/*
+ * In the case of NOR boot we are running from the same address space.
+ * Detect this case to handle it correctly.
+ */
+	mov r1, #S3C_MEMCTL_BASE
+	ldr r3, [r1]
+	and r3, r3, #0x6
+	cmp r3, #0x0	/* check for NAND case */
+	beq 3f
+	mov pc, lr	/* NOR case: nothing to do here */
+#endif
+3:	ldr sp, =TEXT_BASE	/* Setup a temporary stack in SDRAM */
+/*
+ * We still run at a location we are not linked to. But lets still running
+ * from the internal SRAM, this may speed up the boot
+ */
+	push {lr}
+	bl s3c_nand_boot
+	pop {lr}
+/*
+ * Adjust the return address to the correct address in SDRAM
+ */
+	ldr r1, =TEXT_BASE
+	add lr, lr, r1
+
+	mov pc, lr
+
+#endif
+
+/**
+@page dev_s3c64xx_nandboot_handling Booting from NAND
+
+To be able to boot from NAND memory only, enable the S3C24x0 NAND driver. Also
+enable CONFIG_S3C_NAND_BOOT and CONFIG_MACH_HAS_LOWLEVEL_INIT to be
+able to call the s3c64xx_nand_boot() assembler routine from within the
+machine specific board_init_lowlevel() assembler function.
+
+@note This routine assumes an already working SDRAM controller and
+an initialized stack pointer.
+
+@note Basicly this routine runs from inside the internal SRAM. After load of
+the whole barebox image from the NAND flash memory into the SDRAM it adjusts
+the link register to the final SDRAM adress and returns.
+
+@note In the NAND boot mode, ECC is not checked. So, the first x KBytes used
+by barebox should have no bit error.
+
+Due to the fact the code to load the whole barebox from NAND must fit into
+the first 8kiB of the barebox image, the shrinked NAND driver is very
+minimalistic. Setup the NAND access timing is done in a safe manner, what
+means: Slowest possible values are used. If you want to increase the speed you
+should define the BOARD_DEFAULT_NAND_TIMING to a valid setting into the
+NFCONF register and add it to your board specific config.h. Refer S3C64XX's
+datasheet for further details. The macro #CALC_NFCONF_TIMING could help to
+calculate the register setting in a hardware independent manner.
+
+@note The regular NAND driver uses a platform data structure to define the
+NAND access timings.
+
+@note Its still possible to boot this image from NOR memory. If this routine
+detects it is running from NOR instead of the internal SRAM it skips any
+loading and returns immediately.
+
+*/
+
+
+#ifdef CONFIG_S3C_MMC_BOOT
+
+	.section ".text_bare_init.s3c64xx_mmc_boot","ax"
+
+	.globl s3c64xx_mmc_boot
+s3c64xx_mmc_boot:
+	ldr sp, =TEXT_BASE	/* Setup a temporary stack in SDRAM */
+/*
+ * We still run at a location we are not linked to. But lets still running
+ * from the internal SRAM, this may speed up the boot
+ */
+	push {lr}
+	bl s3c_mmc_boot
+	pop {lr}
+/*
+ * Adjust the return address to the correct address in SDRAM
+ */
+	ldr r1, =TEXT_BASE
+	sub lr, lr, #0x0c000000		/* the BL1 is running at 0x0c000000 when boot from mmc */
+	add lr, lr, r1
+
+	mov pc, lr
+#endif
Index: barebox-2014.10.0/drivers/mtd/nand/Makefile
===================================================================
--- barebox-2014.10.0.orig/drivers/mtd/nand/Makefile
+++ barebox-2014.10.0/drivers/mtd/nand/Makefile
@@ -14,4 +14,8 @@ obj-$(CONFIG_NAND_ORION)		+= nand_orion.
 obj-$(CONFIG_NAND_ATMEL)		+= atmel_nand.o
 obj-$(CONFIG_NAND_S3C24XX)		+= nand_s3c24xx.o
 pbl-$(CONFIG_NAND_S3C24XX)		+= nand_s3c24xx.o
+obj-$(CONFIG_NAND_S3C64XX)		+= nand_s3c64xx.o
+pbl-$(CONFIG_NAND_S3C64XX)		+= nand_s3c64xx.o
+obj-$(CONFIG_S3C_NAND_BOOT)		+= nand_s3c_boot.o
+pbl-$(CONFIG_S3C_NAND_BOOT)		+= nand_s3c_boot.o
 obj-$(CONFIG_NAND_MXS)			+= nand_mxs.o
Index: barebox-2014.10.0/drivers/mtd/nand/nand_s3c64xx.c
===================================================================
--- /dev/null
+++ barebox-2014.10.0/drivers/mtd/nand/nand_s3c64xx.c
@@ -0,0 +1,648 @@
+/* linux/drivers/mtd/nand/s3c2410.c
+ *
+ * Copyright © 2004-2008 Simtec Electronics
+ *	http://armlinux.simtec.co.uk/
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * Samsung S3C2410/S3C2440/S3C2412 NAND driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+#include <config.h>
+#include <common.h>
+#include <driver.h>
+#include <malloc.h>
+#include <init.h>
+#include <io.h>
+#include <mach/s3c24xx-nand.h>
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+
+#include <mach/s3c-regs-nand.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+
+/* new oob placement block for use with hardware ecc generation
+ */
+
+static struct nand_ecclayout nand_hw_eccoob = {
+	.eccbytes = 3,
+	.eccpos = {0, 1, 2},
+	.oobfree = {{8, 8}}
+};
+
+
+enum s3c_cpu_type {
+	TYPE_S3C2410,
+	TYPE_S3C2412,
+	TYPE_S3C2440,
+};
+
+/**
+ * struct s3c2410_nand_info - NAND controller state.
+ * @mtds: An array of MTD instances on this controoler.
+ * @platform: The platform data for this board.
+ * @device: The platform device we bound to.
+ * @clk: The clock resource for this controller.
+ * @regs: The area mapped for the hardware registers.
+ * @sel_reg: Pointer to the register controlling the NAND selection.
+ * @sel_bit: The bit in @sel_reg to select the NAND chip.
+ * @mtd_count: The number of MTDs created from this controller.
+ * @cpu_type: The exact type of this controller.
+ */
+struct s3c2410_nand_info {
+	/* mtd info */
+	struct mtd_info			mtd;
+	struct nand_chip		chip;
+
+	struct s3c24x0_nand_platform_data	*platform;
+
+	/* device info */
+	//struct device			*device;
+	struct device_d			*dev;
+	void __iomem			*regs;
+	void __iomem			*sel_reg;
+	int				sel_bit;
+
+	enum s3c_cpu_type		cpu_type;
+};
+
+/* conversion functions */
+
+static struct s3c2410_nand_info *s3c2410_nand_mtd_toinfo(struct mtd_info *mtd)
+{
+	return (struct s3c2410_nand_info *)mtd;
+}
+
+/* controller setup */
+
+/**
+ * s3c2410_nand_inithw - basic hardware initialisation
+ * @info: The hardware state.
+ *
+ * Do the basic initialisation of the hardware, using s3c2410_nand_setrate()
+ * to setup the hardware access speeds and set the controller to be enabled.
+*/
+static int s3c2410_nand_inithw(struct s3c2410_nand_info *info)
+{
+	uint32_t nand_timing = (info->platform ? info->platform->nand_timing : BOARD_DEFAULT_NAND_TIMING);
+	uint32_t cfg;
+
+	switch (info->cpu_type) {
+	case TYPE_S3C2410:
+		cfg = readl(info->regs + S3C2410_NFCONF);
+		cfg &= ~(S3C2410_NFCONF_TACLS(3) |
+			S3C2410_NFCONF_TWRPH0(7) |
+			S3C2410_NFCONF_TWRPH1(7));
+		cfg |= (S3C2410_NFCONF_EN | nand_timing);
+		writel(cfg, info->regs + S3C2410_NFCONF);
+		break;
+
+	case TYPE_S3C2440:
+		cfg = readl(info->regs + S3C2410_NFCONF);
+		cfg &= ~(S3C2440_NFCONF_TACLS(3) |
+			S3C2440_NFCONF_TWRPH0(7) |
+			S3C2440_NFCONF_TWRPH1(7));
+		cfg |= nand_timing;
+		writel(cfg, info->regs + S3C2410_NFCONF);
+
+		writel(S3C2440_NFCONT_ENABLE, info->regs + S3C2440_NFCONT);
+		break;
+	case TYPE_S3C2412:
+		cfg = readl(info->regs + S3C2410_NFCONF);
+		cfg &= ~(S3C2440_NFCONF_TACLS(7) |
+			S3C2440_NFCONF_TWRPH0(7) |
+			S3C2440_NFCONF_TWRPH1(7));
+		cfg |= nand_timing;
+		writel(cfg, info->regs + S3C2410_NFCONF);
+
+		writel(S3C2440_NFCONT_ENABLE, info->regs + S3C2440_NFCONT);
+		break;
+
+	default:
+		BUG();
+	}
+
+	return 0;
+}
+
+/**
+ * s3c2410_nand_select_chip - select the given nand chip
+ * @mtd: The MTD instance for this chip.
+ * @chip: The chip number.
+ *
+ * This is called by the MTD layer to either select a given chip for the
+ * @mtd instance, or to indicate that the access has finished and the
+ * chip can be de-selected.
+ *
+ * The routine ensures that the nFCE line is correctly setup, and any
+ * platform specific selection code is called to route nFCE to the specific
+ * chip.
+ */
+static void s3c2410_nand_select_chip(struct mtd_info *mtd, int chip)
+{
+	struct s3c2410_nand_info *info;
+	unsigned long cur;
+
+	info = s3c2410_nand_mtd_toinfo(mtd);
+
+	cur = readl(info->sel_reg);
+
+	if (chip == -1) {
+		cur |= info->sel_bit;
+	} else {
+		cur &= ~info->sel_bit;
+	}
+
+	writel(cur, info->sel_reg);
+}
+
+/* s3c2410_nand_hwcontrol
+ *
+ * Issue command and address cycles to the chip
+*/
+
+static void s3c2410_nand_hwcontrol(struct mtd_info *mtd, int cmd,
+				   unsigned int ctrl)
+{
+	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
+
+	if (cmd == NAND_CMD_NONE)
+		return;
+
+	if (ctrl & NAND_CLE)
+		writeb(cmd, info->regs + S3C2410_NFCMD);
+	else
+		writeb(cmd, info->regs + S3C2410_NFADDR);
+}
+
+/* command and control functions */
+
+static void s3c2440_nand_hwcontrol(struct mtd_info *mtd, int cmd,
+				   unsigned int ctrl)
+{
+	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
+
+	if (cmd == NAND_CMD_NONE)
+		return;
+
+	if (ctrl & NAND_CLE)
+		writeb(cmd, info->regs + S3C2440_NFCMD);
+	else
+		writeb(cmd, info->regs + S3C2440_NFADDR);
+}
+
+/* s3c2410_nand_devready()
+ *
+ * returns 0 if the nand is busy, 1 if it is ready
+*/
+
+static int s3c2410_nand_devready(struct mtd_info *mtd)
+{
+	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
+	return readb(info->regs + S3C2410_NFSTAT) & S3C2410_NFSTAT_BUSY;
+}
+
+static int s3c2440_nand_devready(struct mtd_info *mtd)
+{
+	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
+	return readb(info->regs + S3C2440_NFSTAT) & S3C2440_NFSTAT_READY;
+}
+
+static int s3c2412_nand_devready(struct mtd_info *mtd)
+{
+	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
+	return readb(info->regs + S3C2412_NFSTAT) & S3C2412_NFSTAT_READY;
+}
+
+/* ECC handling functions */
+
+#if defined(CONFIG_NAND_ECC_HW)
+static int s3c2410_nand_correct_data(struct mtd_info *mtd, u_char *dat,
+				     u_char *read_ecc, u_char *calc_ecc)
+{
+	unsigned int diff0, diff1, diff2;
+	unsigned int bit, byte;
+
+	pr_debug("%s(%p,%p,%p,%p)\n", __func__, mtd, dat, read_ecc, calc_ecc);
+
+	diff0 = read_ecc[0] ^ calc_ecc[0];
+	diff1 = read_ecc[1] ^ calc_ecc[1];
+	diff2 = read_ecc[2] ^ calc_ecc[2];
+
+	pr_debug("%s: rd %*phN calc %*phN diff %02x%02x%02x\n",
+		 __func__, 3, read_ecc, 3, calc_ecc,
+		 diff0, diff1, diff2);
+
+	if (diff0 == 0 && diff1 == 0 && diff2 == 0)
+		return 0;		/* ECC is ok */
+
+	/* Can we correct this ECC (ie, one row and column change).
+	 * Note, this is similar to the 256 error code on smartmedia */
+
+	if (((diff0 ^ (diff0 >> 1)) & 0x55) == 0x55 &&
+	    ((diff1 ^ (diff1 >> 1)) & 0x55) == 0x55 &&
+	    ((diff2 ^ (diff2 >> 1)) & 0x55) == 0x55) {
+		/* calculate the bit position of the error */
+
+		bit  = ((diff2 >> 3) & 1) |
+		       ((diff2 >> 4) & 2) |
+		       ((diff2 >> 5) & 4);
+
+		/* calculate the byte position of the error */
+
+		byte = ((diff2 << 7) & 0x100) |
+		       ((diff1 << 0) & 0x80)  |
+		       ((diff1 << 1) & 0x40)  |
+		       ((diff1 << 2) & 0x20)  |
+		       ((diff1 << 3) & 0x10)  |
+		       ((diff0 >> 4) & 0x08)  |
+		       ((diff0 >> 3) & 0x04)  |
+		       ((diff0 >> 2) & 0x02)  |
+		       ((diff0 >> 1) & 0x01);
+
+		pr_debug("s3c-nand: correcting error bit %d, byte %d\n",
+			bit, byte);
+
+		dat[byte] ^= (1 << bit);
+		return 1;
+	}
+
+	/* if there is only one bit difference in the ECC, then
+	 * one of only a row or column parity has changed, which
+	 * means the error is most probably in the ECC itself */
+
+	diff0 |= (diff1 << 8);
+	diff0 |= (diff2 << 16);
+
+	if ((diff0 & ~(1<<fls(diff0))) == 0)
+		return 1;
+
+	return -1;
+}
+
+/* ECC functions
+ *
+ * These allow the s3c2410 and s3c2440 to use the controller's ECC
+ * generator block to ECC the data as it passes through]
+*/
+
+static void s3c2410_nand_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
+	unsigned long ctrl;
+
+	ctrl = readl(info->regs + S3C2410_NFCONF);
+	ctrl |= S3C2410_NFCONF_INITECC;
+	writel(ctrl, info->regs + S3C2410_NFCONF);
+}
+
+static void s3c2412_nand_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
+	unsigned long ctrl;
+
+	ctrl = readl(info->regs + S3C2440_NFCONT);
+	writel(ctrl | S3C2412_NFCONT_INIT_MAIN_ECC,
+	       info->regs + S3C2440_NFCONT);
+}
+
+static void s3c2440_nand_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
+	unsigned long ctrl;
+
+	ctrl = readl(info->regs + S3C2440_NFCONT);
+	writel(ctrl | S3C2440_NFCONT_INITECC, info->regs + S3C2440_NFCONT);
+}
+
+static int s3c2410_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
+				      u_char *ecc_code)
+{
+	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
+
+	ecc_code[0] = readb(info->regs + S3C2410_NFECC + 0);
+	ecc_code[1] = readb(info->regs + S3C2410_NFECC + 1);
+	ecc_code[2] = readb(info->regs + S3C2410_NFECC + 2);
+
+	pr_debug("%s: returning ecc %*phN\n", __func__, 3, ecc_code);
+
+	return 0;
+}
+
+static int s3c2412_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
+				      u_char *ecc_code)
+{
+	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
+	unsigned long ecc = readl(info->regs + S3C2412_NFMECC0);
+
+	ecc_code[0] = ecc;
+	ecc_code[1] = ecc >> 8;
+	ecc_code[2] = ecc >> 16;
+
+	pr_debug("%s: returning ecc %*phN\n", __func__, 3, ecc_code);
+
+	return 0;
+}
+
+static int s3c2440_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
+				      u_char *ecc_code)
+{
+	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
+	unsigned long ecc = readl(info->regs + S3C2440_NFMECC0);
+
+	ecc_code[0] = ecc;
+	ecc_code[1] = ecc >> 8;
+	ecc_code[2] = ecc >> 16;
+
+	pr_debug("%s: returning ecc %06lx\n", __func__, ecc & 0xffffff);
+
+	return 0;
+}
+#endif
+
+/* over-ride the standard functions for a little more speed. We can
+ * use read/write block to move the data buffers to/from the controller
+*/
+
+static void s3c2410_nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)
+{
+	struct nand_chip *this = mtd->priv;
+	readsb(this->IO_ADDR_R, buf, len);
+}
+
+static void s3c2440_nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)
+{
+	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
+
+	readsl(info->regs + S3C2440_NFDATA, buf, len >> 2);
+
+	/* cleanup if we've got less than a word to do */
+	if (len & 3) {
+		buf += len & ~3;
+
+		for (; len & 3; len--)
+			*buf++ = readb(info->regs + S3C2440_NFDATA);
+	}
+}
+
+static void s3c2410_nand_write_buf(struct mtd_info *mtd, const u_char *buf,
+				   int len)
+{
+	struct nand_chip *this = mtd->priv;
+	writesb(this->IO_ADDR_W, buf, len);
+}
+
+static void s3c2440_nand_write_buf(struct mtd_info *mtd, const u_char *buf,
+				   int len)
+{
+	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
+
+	writesl(info->regs + S3C2440_NFDATA, buf, len >> 2);
+
+	/* cleanup any fractional write */
+	if (len & 3) {
+		buf += len & ~3;
+
+		for (; len & 3; len--, buf++)
+			writeb(*buf, info->regs + S3C2440_NFDATA);
+	}
+}
+
+/**
+ * s3c2410_nand_init_chip - initialise a single instance of an chip
+ * @info: The base NAND controller the chip is on.
+ * @nmtd: The new controller MTD instance to fill in.
+ * @set: The information passed from the board specific platform data.
+ *
+ * Initialise the given @nmtd from the information in @info and @set. This
+ * readies the structure for use with the MTD layer functions by ensuring
+ * all pointers are setup and the necessary control routines selected.
+ */
+static void s3c2410_nand_init_chip(struct s3c2410_nand_info *info,
+				   int flash_bbt)
+{
+	struct nand_chip *chip = &info->chip;
+	void __iomem *regs = info->regs;
+
+	chip->write_buf    = s3c2410_nand_write_buf;
+	chip->read_buf     = s3c2410_nand_read_buf;
+	chip->select_chip  = s3c2410_nand_select_chip;
+	chip->chip_delay   = 50;
+	chip->priv	   = info;
+
+	switch (info->cpu_type) {
+	case TYPE_S3C2410:
+		chip->IO_ADDR_W = regs + S3C2410_NFDATA;
+		info->sel_reg   = regs + S3C2410_NFCONF;
+		info->sel_bit	= S3C2410_NFCONF_nFCE;
+		chip->cmd_ctrl  = s3c2410_nand_hwcontrol;
+		chip->dev_ready = s3c2410_nand_devready;
+		break;
+
+	case TYPE_S3C2440:
+		chip->IO_ADDR_W = regs + S3C2440_NFDATA;
+		info->sel_reg   = regs + S3C2440_NFCONT;
+		info->sel_bit	= S3C2440_NFCONT_nFCE;
+		chip->cmd_ctrl  = s3c2440_nand_hwcontrol;
+		chip->dev_ready = s3c2440_nand_devready;
+		chip->read_buf  = s3c2440_nand_read_buf;
+		chip->write_buf	= s3c2440_nand_write_buf;
+		break;
+
+	case TYPE_S3C2412:
+		chip->IO_ADDR_W = regs + S3C2440_NFDATA;
+		info->sel_reg   = regs + S3C2440_NFCONT;
+		info->sel_bit	= S3C2412_NFCONT_nFCE0;
+		chip->cmd_ctrl  = s3c2440_nand_hwcontrol;
+		chip->dev_ready = s3c2412_nand_devready;
+		break;
+	}
+
+	chip->IO_ADDR_R = chip->IO_ADDR_W;
+
+	info->mtd.priv	   = chip;
+#if defined(CONFIG_NAND_ECC_HW)
+	chip->ecc.calculate = s3c2410_nand_calculate_ecc;
+	chip->ecc.correct   = s3c2410_nand_correct_data;
+	chip->ecc.mode	    = NAND_ECC_HW;
+	chip->ecc.strength  = 1;
+
+	switch (info->cpu_type) {
+	case TYPE_S3C2410:
+		chip->ecc.hwctl	    = s3c2410_nand_enable_hwecc;
+		chip->ecc.calculate = s3c2410_nand_calculate_ecc;
+		break;
+
+	case TYPE_S3C2412:
+		chip->ecc.hwctl     = s3c2412_nand_enable_hwecc;
+		chip->ecc.calculate = s3c2412_nand_calculate_ecc;
+		break;
+
+	case TYPE_S3C2440:
+		chip->ecc.hwctl     = s3c2440_nand_enable_hwecc;
+		chip->ecc.calculate = s3c2440_nand_calculate_ecc;
+		break;
+	}
+#elif defined(CONFIG_NAND_ECC_SOFT)
+	chip->ecc.mode	= NAND_ECC_SOFT;
+#else
+	chip->ecc.mode	= NAND_ECC_NONE;
+#endif
+
+	/* If you use u-boot BBT creation code, specifying this flag will
+	 * let the kernel fish out the BBT from the NAND, and also skip the
+	 * full NAND scan that can take 1/2s or so. Little things... */
+	if (flash_bbt) {
+		chip->bbt_options |= NAND_BBT_USE_FLASH;
+		chip->options |= NAND_SKIP_BBTSCAN;
+	}
+}
+
+/**
+ * s3c2410_nand_update_chip - post probe update
+ * @info: The controller instance.
+ * @nmtd: The driver version of the MTD instance.
+ *
+ * This routine is called after the chip probe has successfully completed
+ * and the relevant per-chip information updated. This call ensure that
+ * we update the internal state accordingly.
+ *
+ * The internal state is currently limited to the ECC state information.
+*/
+static void s3c2410_nand_update_chip(struct s3c2410_nand_info *info)
+{
+	struct nand_chip *chip = &info->chip;
+
+	pr_debug("s3c-nand: chip %p => page shift %d\n",
+		chip, chip->page_shift);
+
+	if (chip->ecc.mode != NAND_ECC_HW)
+		return;
+
+		/* change the behaviour depending on whether we are using
+		 * the large or small page nand device */
+
+	if (chip->page_shift > 10) {
+		chip->ecc.size	    = 256;
+		chip->ecc.bytes	    = 3;
+	} else {
+		chip->ecc.size	    = 512;
+		chip->ecc.bytes	    = 3;
+		chip->ecc.layout    = &nand_hw_eccoob;
+	}
+}
+
+/* s3c24xx_nand_probe
+ *
+ * called by device layer when it finds a device matching
+ * one our driver can handled. This code checks to see if
+ * it can allocate all necessary resources then calls the
+ * nand layer to look for devices
+*/
+static int s3c24xx_nand_probe(struct device_d *pdev)
+{
+	struct s3c24x0_nand_platform_data *plat = pdev->platform_data;
+	struct s3c2410_nand_info *info;
+	struct resource *res;
+	int err = 0;
+	int scan_res = 0;
+
+	pr_debug("%s (%p)\n", __func__, pdev);
+
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
+	if (info == NULL) {
+		pr_err("s3c-nand: no memory for flash info\n");
+		return -ENOMEM;
+	}
+
+	info->dev = pdev;
+
+	/* allocate and map the resource */
+
+	/* currently we assume we have the one resource */
+	res = pdev->resource;
+
+	info->platform	= plat;
+	info->cpu_type	= pdev->id_entry->driver_data;
+
+	info->regs = dev_request_mem_region(pdev, 0);
+	if (IS_ERR(info->regs)) {
+		err = PTR_ERR(info->regs);
+		pr_err("s3c-nand: dev_request_mem_region %d\n", err);
+		goto exit_error;
+	}
+
+	pr_debug("s3c-nand: mapped registers at %p\n", info->regs);
+
+	/* initialise the hardware */
+
+	err = s3c2410_nand_inithw(info);
+	if (err < 0) {
+		pr_err("s3c-nand: s3c2410_nand_inithw %d\n", err);
+		goto exit_error;
+	}
+
+	/* initialise all possible chips */
+	info->mtd.parent = pdev;
+
+	s3c2410_nand_init_chip(info, plat->flash_bbt);
+
+	scan_res = nand_scan_ident(&info->mtd, 1, NULL);
+	if (scan_res == 0) {
+		s3c2410_nand_update_chip(info);
+		nand_scan_tail(&info->mtd);
+	}
+
+	return add_mtd_nand_device(&info->mtd, "nand");
+
+ exit_error:
+	free(info);
+
+	return err;
+}
+
+/* driver device registration */
+
+static struct platform_device_id s3c24xx_driver_ids[] = {
+	{
+		.name		= "s3c2410-nand",
+		.driver_data	= TYPE_S3C2410,
+	}, {
+		.name		= "s3c2440-nand",
+		.driver_data	= TYPE_S3C2440,
+	}, {
+		.name		= "s3c2412-nand",
+		.driver_data	= TYPE_S3C2412,
+	}, {
+		.name		= "s3c6400-nand",
+		.driver_data	= TYPE_S3C2412, /* compatible with 2412 */
+	},
+	{ }
+};
+
+static struct driver_d s3c24x0_nand_driver = {
+	.probe		= s3c24xx_nand_probe,
+	.id_table	= s3c24xx_driver_ids,
+	.name		= "s3c24xx_nand",
+};
+device_platform_driver(s3c24x0_nand_driver);
Index: barebox-2014.10.0/arch/arm/boards/njjl-arm11plf/lowlevel_init.S
===================================================================
--- /dev/null
+++ barebox-2014.10.0/arch/arm/boards/njjl-arm11plf/lowlevel_init.S
@@ -0,0 +1,62 @@
+/*
+ * Low level initialization for the Nanjing Jilong Arm11plf board
+ */
+
+#include <config.h>
+#include <sizes.h>
+#include <mach/s3c-iomap.h>
+#include <asm/barebox-arm-head.h>
+
+	.section ".text_bare_init.barebox_arm_reset_vector","ax"
+
+/* ------------------------------------------------------------------------ */
+
+.globl barebox_arm_reset_vector
+barebox_arm_reset_vector:
+	/* Peri port setup */
+	ldr r0, =0x70000000
+	orr r0, r0, #0x13		@ 256M(0x70000000-0x7fffffff)
+	mcr p15, 0, r0, c15, c2, 4
+
+	bl arm_cpu_lowlevel_init
+
+	bl s3c64xx_disable_wd
+
+	/* skip everything here if we are already running from SDRAM */
+	cmp pc, #S3C_SDRAM_BASE
+	blo 1f
+	cmp pc, #S3C_SDRAM_END
+	bhs 1f
+
+	b out
+/* we are running from NOR or NAND/SRAM memory. Do further initialisation */
+1:
+	bl s3c64xx_pll_init
+	bl s3c64xx_sdram_init
+
+	/* check if we booted from nand or mmc*/
+	ldr	r1, =0x7E00F12C		/* reg  MEM_CFG_STAT*/
+	ldr	r0, [r1]
+#ifdef CONFIG_S3C_MMC_BOOT
+	mov 	r1, #0xE0
+	and	r1, r0, r1		/*r1 = MEM_CFG_STAT & CFG_BOOT_LOC */
+	cmp	r1, #0x60		/*Internal ROM*/
+	bne check_nand
+	bl s3c64xx_mmc_boot
+	b out
+#endif
+check_nand:
+#ifdef CONFIG_S3C_NAND_BOOT
+	mov 	r1, #0xE0
+	and	r1, r0, r1		/*r1 = MEM_CFG_STAT & CFG_BOOT_LOC */
+	cmp	r1, #0x80
+	bne out
+	bl s3c64xx_nand_boot
+	b out
+#endif
+out:
+	/* args */
+	ldr r0, =S3C_SDRAM_BASE
+	ldr r1, =SZ_128M
+	ldr r2, =0
+	b barebox_arm_entry
Index: barebox-2014.10.0/arch/arm/mach-samsung/include/mach/s3c24xx-nand.h
===================================================================
--- barebox-2014.10.0.orig/arch/arm/mach-samsung/include/mach/s3c24xx-nand.h
+++ barebox-2014.10.0/arch/arm/mach-samsung/include/mach/s3c24xx-nand.h
@@ -38,6 +38,10 @@ extern void s3c24x0_nand_load_image(void
 # define CALC_NFCONF_TIMING(setup, access, hold) \
 	((setup << 12) + (access << 8) + (hold << 4))
 #endif
+#ifdef CONFIG_CPU_S3C6410
+# define CALC_NFCONF_TIMING(setup, access, hold) \
+	((setup << 12) + (access << 8) + (hold << 4))
+#endif
 
 /**
  * Define platform specific data for the NAND controller and its device
Index: barebox-2014.10.0/drivers/mtd/nand/Kconfig
===================================================================
--- barebox-2014.10.0.orig/drivers/mtd/nand/Kconfig
+++ barebox-2014.10.0/drivers/mtd/nand/Kconfig
@@ -117,6 +117,13 @@ config NAND_S3C24XX
 	help
 	  Add support for processor's NAND device controller.
 
+config NAND_S3C64XX
+	bool
+	prompt "Samsung S3C64XX NAND driver"
+	depends on ARCH_S3C64xx
+	help
+	  Add support for processor's NAND device controller.
+
 config MTD_NAND_ECC_SMC
 	bool "NAND ECC Smart Media byte order"
 	default n
Index: barebox-2014.10.0/arch/arm/mach-samsung/include/mach/s3c-regs-nand.h
===================================================================
--- /dev/null
+++ barebox-2014.10.0/arch/arm/mach-samsung/include/mach/s3c-regs-nand.h
@@ -0,0 +1,124 @@
+/* arch/arm/mach-s3c2410/include/mach/regs-nand.h
+ *
+ * Copyright (c) 2004-2005 Simtec Electronics <linux@simtec.co.uk>
+ *	http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C2410 NAND register definitions
+*/
+
+#ifndef __ASM_ARM_REGS_NAND
+#define __ASM_ARM_REGS_NAND
+
+
+#define S3C2410_NFREG(x) (x)
+
+#define S3C2410_NFCONF  S3C2410_NFREG(0x00)
+#define S3C2410_NFCMD   S3C2410_NFREG(0x04)
+#define S3C2410_NFADDR  S3C2410_NFREG(0x08)
+#define S3C2410_NFDATA  S3C2410_NFREG(0x0C)
+#define S3C2410_NFSTAT  S3C2410_NFREG(0x10)
+#define S3C2410_NFECC   S3C2410_NFREG(0x14)
+
+#define S3C2440_NFCONT   S3C2410_NFREG(0x04)
+#define S3C2440_NFCMD    S3C2410_NFREG(0x08)
+#define S3C2440_NFADDR   S3C2410_NFREG(0x0C)
+#define S3C2440_NFDATA   S3C2410_NFREG(0x10)
+#define S3C2440_NFECCD0  S3C2410_NFREG(0x14)
+#define S3C2440_NFECCD1  S3C2410_NFREG(0x18)
+#define S3C2440_NFECCD   S3C2410_NFREG(0x1C)
+#define S3C2440_NFSTAT   S3C2410_NFREG(0x20)
+#define S3C2440_NFESTAT0 S3C2410_NFREG(0x24)
+#define S3C2440_NFESTAT1 S3C2410_NFREG(0x28)
+#define S3C2440_NFMECC0  S3C2410_NFREG(0x2C)
+#define S3C2440_NFMECC1  S3C2410_NFREG(0x30)
+#define S3C2440_NFSECC   S3C2410_NFREG(0x34)
+#define S3C2440_NFSBLK   S3C2410_NFREG(0x38)
+#define S3C2440_NFEBLK   S3C2410_NFREG(0x3C)
+
+#define S3C2412_NFSBLK		S3C2410_NFREG(0x20)
+#define S3C2412_NFEBLK		S3C2410_NFREG(0x24)
+#define S3C2412_NFSTAT		S3C2410_NFREG(0x28)
+#define S3C2412_NFMECC_ERR0	S3C2410_NFREG(0x2C)
+#define S3C2412_NFMECC_ERR1	S3C2410_NFREG(0x30)
+#define S3C2412_NFMECC0		S3C2410_NFREG(0x34)
+#define S3C2412_NFMECC1		S3C2410_NFREG(0x38)
+#define S3C2412_NFSECC		S3C2410_NFREG(0x3C)
+
+#define S3C2410_NFCONF_EN          (1<<15)
+#define S3C2410_NFCONF_512BYTE     (1<<14)
+#define S3C2410_NFCONF_4STEP       (1<<13)
+#define S3C2410_NFCONF_INITECC     (1<<12)
+#define S3C2410_NFCONF_nFCE        (1<<11)
+#define S3C2410_NFCONF_TACLS(x)    ((x)<<8)
+#define S3C2410_NFCONF_TWRPH0(x)   ((x)<<4)
+#define S3C2410_NFCONF_TWRPH1(x)   ((x)<<0)
+
+#define S3C2410_NFSTAT_BUSY        (1<<0)
+
+#define S3C2440_NFCONF_BUSWIDTH_8	(0<<0)
+#define S3C2440_NFCONF_BUSWIDTH_16	(1<<0)
+#define S3C2440_NFCONF_ADVFLASH		(1<<3)
+#define S3C2440_NFCONF_TACLS(x)		((x)<<12)
+#define S3C2440_NFCONF_TWRPH0(x)	((x)<<8)
+#define S3C2440_NFCONF_TWRPH1(x)	((x)<<4)
+
+#define S3C2440_NFCONT_LOCKTIGHT	(1<<13)
+#define S3C2440_NFCONT_SOFTLOCK		(1<<12)
+#define S3C2440_NFCONT_ILLEGALACC_EN	(1<<10)
+#define S3C2440_NFCONT_RNBINT_EN	(1<<9)
+#define S3C2440_NFCONT_RN_FALLING	(1<<8)
+#define S3C2440_NFCONT_SPARE_ECCLOCK	(1<<6)
+#define S3C2440_NFCONT_MAIN_ECCLOCK	(1<<5)
+#define S3C2440_NFCONT_INITECC		(1<<4)
+#define S3C2440_NFCONT_nFCE		(1<<1)
+#define S3C2440_NFCONT_ENABLE		(1<<0)
+
+#define S3C2440_NFSTAT_READY		(1<<0)
+#define S3C2440_NFSTAT_nCE		(1<<1)
+#define S3C2440_NFSTAT_RnB_CHANGE	(1<<2)
+#define S3C2440_NFSTAT_ILLEGAL_ACCESS	(1<<3)
+
+#define S3C2412_NFCONF_NANDBOOT		(1<<31)
+#define S3C2412_NFCONF_ECCCLKCON	(1<<30)
+#define S3C2412_NFCONF_ECC_MLC		(1<<24)
+#define S3C2412_NFCONF_TACLS_MASK	(7<<12)	/* 1 extra bit of Tacls */
+
+#define S3C2412_NFCONT_ECC4_DIRWR	(1<<18)
+#define S3C2412_NFCONT_LOCKTIGHT	(1<<17)
+#define S3C2412_NFCONT_SOFTLOCK		(1<<16)
+#define S3C2412_NFCONT_ECC4_ENCINT	(1<<13)
+#define S3C2412_NFCONT_ECC4_DECINT	(1<<12)
+#define S3C2412_NFCONT_MAIN_ECC_LOCK	(1<<7)
+#define S3C2412_NFCONT_INIT_MAIN_ECC	(1<<5)
+#define S3C2412_NFCONT_nFCE1		(1<<2)
+#define S3C2412_NFCONT_nFCE0		(1<<1)
+
+#define S3C2412_NFSTAT_ECC_ENCDONE	(1<<7)
+#define S3C2412_NFSTAT_ECC_DECDONE	(1<<6)
+#define S3C2412_NFSTAT_ILLEGAL_ACCESS	(1<<5)
+#define S3C2412_NFSTAT_RnB_CHANGE	(1<<4)
+#define S3C2412_NFSTAT_nFCE1		(1<<3)
+#define S3C2412_NFSTAT_nFCE0		(1<<2)
+#define S3C2412_NFSTAT_Res1		(1<<1)
+#define S3C2412_NFSTAT_READY		(1<<0)
+
+#define S3C2412_NFECCERR_SERRDATA(x)	(((x) >> 21) & 0xf)
+#define S3C2412_NFECCERR_SERRBIT(x)	(((x) >> 18) & 0x7)
+#define S3C2412_NFECCERR_MERRDATA(x)	(((x) >> 7) & 0x3ff)
+#define S3C2412_NFECCERR_MERRBIT(x)	(((x) >> 4) & 0x7)
+#define S3C2412_NFECCERR_SPARE_ERR(x)	(((x) >> 2) & 0x3)
+#define S3C2412_NFECCERR_MAIN_ERR(x)	(((x) >> 2) & 0x3)
+#define S3C2412_NFECCERR_NONE		(0)
+#define S3C2412_NFECCERR_1BIT		(1)
+#define S3C2412_NFECCERR_MULTIBIT	(2)
+#define S3C2412_NFECCERR_ECCAREA	(3)
+
+
+
+#endif /* __ASM_ARM_REGS_NAND */
+
+
Index: barebox-2014.10.0/drivers/mtd/nand/nand_s3c_boot.c
===================================================================
--- /dev/null
+++ barebox-2014.10.0/drivers/mtd/nand/nand_s3c_boot.c
@@ -0,0 +1,354 @@
+/* linux/drivers/mtd/nand/s3c2410.c
+ *
+ * Copyright (C) 2009 Juergen Beisert, Pengutronix
+ *
+ * Copyright © 2004-2008 Simtec Electronics
+ *	http://armlinux.simtec.co.uk/
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * Samsung S3C2410 NAND driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+*/
+
+#include <config.h>
+#include <common.h>
+#include <driver.h>
+#include <malloc.h>
+#include <init.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <mach/s3c-generic.h>
+#include <mach/s3c-iomap.h>
+#include <mach/s3c24xx-nand.h>
+#include <io.h>
+#include <asm-generic/errno.h>
+#include <asm/sections.h>
+
+#include <mach/s3c-regs-nand.h>
+
+/// s3c cpu type
+#define TYPE_S3C2410 0
+#define TYPE_S3C2412 1
+#define TYPE_S3C2440 2
+
+#if defined(CONFIG_CPU_S3C2410)
+#define S3C_CPU_TYPE TYPE_S3C2410
+#elif defined(CONFIG_CPU_S3C2440)
+#define S3C_CPU_TYPE TYPE_S3C2440
+#elif defined(CONFIG_CPU_S3C6410)
+#define S3C_CPU_TYPE TYPE_S3C2412
+#else
+#error "the s3c boot code can't support the configured cpu"
+#endif
+
+# ifndef BOARD_DEFAULT_NAND_TIMING
+#  define BOARD_DEFAULT_NAND_TIMING 0x0737
+# endif
+
+/**
+ * Define this symbol for testing purpose. It will add a command to read an
+ * image from the NAND like it the boot strap code will do.
+ */
+#define CONFIG_NAND_S3C_BOOT_DEBUG
+
+/* - Functions shared between the boot strap code and the regular driver - */
+
+/**
+ * Issue the specified command to the NAND device
+ * @param[in] host Base address of the NAND controller
+ * @param[in] cmd Command for NAND flash
+ */
+static inline void __bare_init send_cmd(void __iomem *host, uint8_t cmd)
+{
+#if (S3C_CPU_TYPE == TYPE_S3C2410)
+	writeb(cmd, host + S3C2410_NFCMD);
+#elif (S3C_CPU_TYPE == TYPE_S3C2412)
+	writeb(cmd, host + S3C2440_NFCMD);
+#elif (S3C_CPU_TYPE == TYPE_S3C2440)
+	writeb(cmd, host + S3C2440_NFCMD);
+#else
+#error "the s3c boot code can't support the configured cpu"
+#endif
+}
+
+/**
+ * Issue the specified address to the NAND device
+ * @param[in] host Base address of the NAND controller
+ * @param[in] addr Address for the NAND flash
+ */
+static inline void __bare_init send_addr(void __iomem *host, uint8_t addr)
+{
+#if (S3C_CPU_TYPE == TYPE_S3C2410)
+	writeb(addr, host + S3C2410_NFADDR);
+#elif (S3C_CPU_TYPE == TYPE_S3C2412)
+	writeb(addr, host + S3C2440_NFADDR);
+#elif (S3C_CPU_TYPE == TYPE_S3C2440)
+	writeb(addr, host + S3C2440_NFADDR);
+#else
+#error "the s3c boot code can't support the configured cpu"
+#endif
+}
+
+/**
+ * Enable the NAND flash access
+ * @param[in] host Base address of the NAND controller
+ */
+static inline void __bare_init enable_cs(void __iomem *host)
+{
+#if (S3C_CPU_TYPE == TYPE_S3C2410)
+		void __iomem * const sel_reg = host + S3C2410_NFCONF;
+		uint32_t const sel_bit = S3C2410_NFCONF_nFCE;
+#elif (S3C_CPU_TYPE == TYPE_S3C2412)
+		void __iomem * const sel_reg = host + S3C2440_NFCONT;
+		uint32_t const sel_bit = S3C2412_NFCONT_nFCE0;
+#elif (S3C_CPU_TYPE == TYPE_S3C2440)
+		void __iomem * const sel_reg = host + S3C2440_NFCONT;
+		uint32_t const sel_bit = S3C2440_NFCONT_nFCE;
+#else
+#error "the s3c boot code can't support the configured cpu"
+#endif
+	writel((readl(sel_reg) & ~sel_bit), sel_reg);
+}
+
+/**
+ * Disable the NAND flash access
+ * @param[in] host Base address of the NAND controller
+ */
+static inline void __bare_init disable_cs(void __iomem *host)
+{
+#if (S3C_CPU_TYPE == TYPE_S3C2410)
+		void __iomem * const sel_reg = host + S3C2410_NFCONF;
+		uint32_t const sel_bit = S3C2410_NFCONF_nFCE;
+#elif (S3C_CPU_TYPE == TYPE_S3C2412)
+		void __iomem * const sel_reg = host + S3C2440_NFCONT;
+		uint32_t const sel_bit = S3C2412_NFCONT_nFCE0;
+#elif (S3C_CPU_TYPE == TYPE_S3C2440)
+		void __iomem * const sel_reg = host + S3C2440_NFCONT;
+		uint32_t const sel_bit = S3C2440_NFCONT_nFCE;
+#else
+#error "the s3c boot code can't support the configured cpu"
+#endif
+	writel((readl(sel_reg) | sel_bit), sel_reg);
+}
+
+/**
+ * Enable the NAND flash controller
+ * @param[in] host Base address of the NAND controller
+ * @param[in] timing Timing to access the NAND memory
+ */
+static inline void __bare_init enable_nand_controller(void __iomem *host, uint32_t timing)
+{
+	uint32_t cfg;
+#if (S3C_CPU_TYPE == TYPE_S3C2410)
+		cfg = readl(host + S3C2410_NFCONF);
+		cfg &= ~(S3C2410_NFCONF_TACLS(3) |
+			S3C2410_NFCONF_TWRPH0(7) |
+			S3C2410_NFCONF_TWRPH1(7));
+		cfg |= (S3C2410_NFCONF_EN | timing);
+		writel(cfg, host + S3C2410_NFCONF);
+#elif (S3C_CPU_TYPE == TYPE_S3C2412)
+		cfg = readl(host + S3C2410_NFCONF);
+		cfg &= ~(S3C2440_NFCONF_TACLS(7) |
+			S3C2440_NFCONF_TWRPH0(7) |
+			S3C2440_NFCONF_TWRPH1(7));
+		cfg |= timing;
+		writel(cfg, host + S3C2410_NFCONF);
+
+		writel(host + S3C2440_NFCONT, 0x7E00FA00);
+		writel(S3C2440_NFCONT_ENABLE, 0x7E00FA04);
+
+		writel(S3C2440_NFCONT_ENABLE, host + S3C2440_NFCONT);
+#elif (S3C_CPU_TYPE == TYPE_S3C2440)
+		cfg = readl(host + S3C2410_NFCONF);
+		cfg &= ~(S3C2440_NFCONF_TACLS(3) |
+			S3C2440_NFCONF_TWRPH0(7) |
+			S3C2440_NFCONF_TWRPH1(7));
+		cfg |= timing;
+		writel(cfg, host + S3C2410_NFCONF);
+		writel(cfg, host + S3C2410_NFCONF);
+
+		writel(S3C2440_NFCONT_ENABLE, host + S3C2440_NFCONT);
+#else
+#error "the s3c boot code can't support the configured cpu"
+#endif
+}
+
+static inline void __bare_init wait_for_completion(void __iomem *host)
+{
+	while (!(
+#if (S3C_CPU_TYPE == TYPE_S3C2410)
+		readl(host + S3C2410_NFSTAT) & S3C2410_NFSTAT_BUSY
+#elif (S3C_CPU_TYPE == TYPE_S3C2412)
+		readl(host + S3C2412_NFSTAT) & S3C2412_NFSTAT_READY
+#elif (S3C_CPU_TYPE == TYPE_S3C2440)
+		readl(host + S3C2440_NFSTAT) & S3C2440_NFSTAT_READY
+#else
+#error "the s3c boot code can't support the configured cpu"
+#endif
+	)) {
+		;
+	};
+}
+
+static inline uint8_t __bare_init read_data_u8(void __iomem * host)
+{
+#if (S3C_CPU_TYPE == TYPE_S3C2410)
+	return readb(host + S3C2410_NFDATA);
+#elif (S3C_CPU_TYPE == TYPE_S3C2412)
+	return readb(host + S3C2440_NFDATA);
+#elif (S3C_CPU_TYPE == TYPE_S3C2440)
+	return readb(host + S3C2440_NFDATA);
+#else
+#error "the s3c boot code can't support the configured cpu"
+#endif
+
+
+}
+
+/**
+ * Convert a page offset into a page address for the NAND
+ * @param host Where to write the address to
+ * @param offs Page's offset in the NAND
+ * @param ps Page size (512 or 2048)
+ * @param c Address cycle count (3, 4 or 5)
+ *
+ * Uses the offset of the page to generate an page address into the NAND. This
+ * differs when using a 512 byte or 2048 bytes per page NAND.
+ * The collumn part of the page address to be generated is always forced to '0'.
+ */
+static inline void __bare_init nfc_addr(void __iomem *host, uint32_t offs,
+					int ps, int c)
+{
+	send_addr(host, 0); /* collumn part 1 */
+
+	if (ps == 512) {
+		send_addr(host, offs >> 9);
+		send_addr(host, offs >> 17);
+		if (c > 3)
+			send_addr(host, offs >> 25);
+	} else {
+		send_addr(host, 0); /* collumn part 2 */
+		send_addr(host, offs >> 11);
+		send_addr(host, offs >> 19);
+		if (c > 4)
+			send_addr(host, offs >> 27);
+		send_cmd(host, NAND_CMD_READSTART);
+	}
+}
+
+/**
+ * Load a sequential count of pages from the NAND into memory
+ * @param[out] dest Pointer to target area (in SDRAM)
+ * @param[in] size Bytes to read from NAND device
+ * @param[in] page Start page to read from
+ *
+ * This function must be located in the first 4kiB of the barebox image
+ * (guess why).
+ */
+static void __bare_init s3c_nand_load_image(void *dest, int size)
+{
+	void __iomem * const host = (void __iomem *)S3C_NAND_BASE;
+	unsigned pagesize;
+	int i, cycle;
+	int page = 0;
+
+	/*
+	 * Reenable the NFC and use the default (but slow) access
+	 * timing or the board specific setting if provided.
+	 */
+	enable_nand_controller(host, BOARD_DEFAULT_NAND_TIMING);
+#if defined(CONFIG_ARCH_S3C24xx)
+	/* use the current NAND hardware configuration */
+	switch (readl(S3C24X0_NAND_BASE) & 0xf) {
+	case 0x6:	/* 8 bit, 4 addr cycles, 512 bpp, normal NAND */
+		pagesize = 512;
+		cycle = 4;
+		break;
+	case 0xc:	/* 8 bit, 4 addr cycles, 2048 bpp, advanced NAND */
+		pagesize = 2048;
+		cycle = 4;
+		break;
+	case 0xe:	/* 8 bit, 5 addr cycles, 2048 bpp, advanced NAND */
+		pagesize = 2048;
+		cycle = 5;
+		break;
+	default:
+		/* we cannot output an error message here :-( */
+		return;
+	}
+#elif defined(CONFIG_ARCH_S3C64xx)
+	pagesize = BOARD_SPECIFIC_NAND_PAGESIZE;
+	cycle = BOARD_SPECIFIC_NAND_ADDRCYCLE;
+#endif
+
+	enable_cs(host);
+
+	/* Reset the NAND device */
+	send_cmd(host, NAND_CMD_RESET);
+	wait_for_completion(host);
+	disable_cs(host);
+
+	do {
+		enable_cs(host);
+		send_cmd(host, NAND_CMD_READ0);
+		nfc_addr(host, page * pagesize, pagesize, cycle);
+		wait_for_completion(host);
+		/* copy one page (do *not* use readsb() here!)*/
+		for (i = 0; i < pagesize; i++)
+			writeb(read_data_u8(host), (void __iomem *)(dest + i));
+		disable_cs(host);
+
+		page++;
+		dest += pagesize;
+		size -= pagesize;
+	} while (size >= 0);
+}
+
+void __bare_init s3c_nand_boot(void)
+{
+	void *dest = _text;
+	int size = ld_var(_barebox_image_size);
+
+	s3c_nand_load_image(dest, size);
+}
+#ifdef CONFIG_NAND_S3C_BOOT_DEBUG
+#include <command.h>
+
+static int do_nand_boot_test(int argc, char *argv[])
+{
+	void *dest;
+	int size;
+
+	if (argc < 3)
+		return COMMAND_ERROR_USAGE;
+
+	dest = (void *)strtoul_suffix(argv[1], NULL, 0);
+	size = strtoul_suffix(argv[2], NULL, 0);
+
+	s3c_nand_load_image(dest, size);
+
+	/* re-enable the controller again, as this was a test only */
+	enable_nand_controller((void *)S3C_NAND_BASE,
+				BOARD_DEFAULT_NAND_TIMING);
+
+	return 0;
+}
+
+
+BAREBOX_CMD_START(nand_boot_test)
+	.cmd		= do_nand_boot_test,
+	BAREBOX_CMD_DESC("load an image from NAND")
+	BAREBOX_CMD_OPTS("DEST SIZE")
+	BAREBOX_CMD_GROUP(CMD_GRP_BOOT)
+BAREBOX_CMD_END
+#endif
Index: barebox-2014.10.0/drivers/mci/Kconfig
===================================================================
--- barebox-2014.10.0.orig/drivers/mci/Kconfig
+++ barebox-2014.10.0/drivers/mci/Kconfig
@@ -56,6 +56,13 @@ config MCI_S3C
 	  Enable this entry to add support to read and write SD cards on a
 	  Samsung S3C24xx based system.
 
+config MCI_S3C64XX
+	bool "S3C64XX"
+	depends on ARCH_S3C64xx
+	help
+	  Enable this entry to add support to read and write SD cards on a
+	  Samsung S3C64xx based system.
+
 config MCI_BCM2835
 	bool "MCI support for BCM2835"
 	depends on ARCH_BCM2835
Index: barebox-2014.10.0/drivers/mci/sdhci-s3c.c
===================================================================
--- /dev/null
+++ barebox-2014.10.0/drivers/mci/sdhci-s3c.c
@@ -0,0 +1,532 @@
+/* linux/drivers/mmc/host/sdhci-s3c.c
+ *
+ * Copyright 2008 Openmoko Inc.
+ * Copyright 2008 Simtec Electronics
+ *      Ben Dooks <ben@simtec.co.uk>
+ *      http://armlinux.simtec.co.uk/
+ *
+ * SDHCI (HSMMC) support for Samsung SoC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <common.h>
+#include <init.h>
+#include <mci.h>
+#include <errno.h>
+#include <clock.h>
+#include <io.h>
+#include <mach/s3c-mci.h>
+#include <mach/s3c-generic.h>
+#include <mach/s3c-iomap.h>
+
+struct s3c64x0_mmc {
+	unsigned int	sysad;
+	unsigned short	blksize;
+	unsigned short	blkcnt;
+	unsigned int	argument;
+	unsigned short	trnmod;
+	unsigned short	cmdreg;
+	unsigned int	rspreg0;
+	unsigned int	rspreg1;
+	unsigned int	rspreg2;
+	unsigned int	rspreg3;
+	unsigned int	bdata;
+	unsigned int	prnsts;
+	unsigned char	hostctl;
+	unsigned char	pwrcon;
+	unsigned char	blkgap;
+	unsigned char	wakcon;
+	unsigned short	clkcon;
+	unsigned char	timeoutcon;
+	unsigned char	swrst;
+	unsigned int	norintsts;	/* errintsts */
+	unsigned int	norintstsen;	/* errintstsen */
+	unsigned int	norintsigen;	/* errintsigen */
+	unsigned short	acmd12errsts;
+	unsigned char	res1[2];
+	unsigned int	capareg;
+	unsigned char	res2[4];
+	unsigned int	maxcurr;
+	unsigned char	res3[0x34];
+	unsigned int	control2;
+	unsigned int	control3;
+	unsigned int	control4;
+	unsigned char	res4[0x6e];
+	unsigned short	hcver;
+};
+
+/**
+ * struct mmc_host - S3C SDHCI instance
+ */
+struct mmc_host {
+	struct mci_host	host;
+	struct s3c64x0_mmc __iomem *reg;
+	unsigned int version;	/* SDHCI spec. version */
+	unsigned int clock;	/* Current clock (MHz) */
+};
+
+#define to_s3c_host(h)	container_of(h, struct mmc_host, host)
+
+static int mmc_card_detect(struct mci_host *mci_host)
+{
+	struct mmc_host * host = to_s3c_host(mci_host);
+	unsigned int reg_val = readl(&host->reg->prnsts);
+	pr_info("detect mmc: %d\n", reg_val & (0x5 << 16));
+	return (reg_val & (0x5 << 16));
+}
+
+static void mmc_prepare_data(struct mmc_host *host, struct mci_data *data)
+{
+	unsigned char ctrl;
+
+	debug("data->dest: %08x\n", (u32)data->dest);
+	writel((u32)data->dest, &host->reg->sysad);
+	/*
+	 * DMASEL[4:3]
+	 * 00 = Selects SDMA
+	 * 01 = Reserved
+	 * 10 = Selects 32-bit Address ADMA2
+	 * 11 = Selects 64-bit Address ADMA2
+	 */
+	ctrl = readb(&host->reg->hostctl);
+	ctrl &= ~(3 << 3);
+	writeb(ctrl, &host->reg->hostctl);
+
+	/* We do not handle DMA boundaries, so set it to max (512 KiB) */
+	writew((7 << 12) | (data->blocksize << 0), &host->reg->blksize);
+	writew(data->blocks, &host->reg->blkcnt);
+}
+
+static void mmc_set_transfer_mode(struct mmc_host *host, struct mci_data *data)
+{
+	unsigned short mode;
+
+	/*
+	 * TRNMOD
+	 * MUL1SIN0[5]	: Multi/Single Block Select
+	 * RD1WT0[4]	: Data Transfer Direction Select
+	 *	1 = read
+	 *	0 = write
+	 * ENACMD12[2]	: Auto CMD12 Enable
+	 * ENBLKCNT[1]	: Block Count Enable
+	 * ENDMA[0]	: DMA Enable
+	 */
+	mode = (1 << 1) | (1 << 0);
+	if (data->blocks > 1)
+		mode |= (1 << 5);
+	if (data->flags & MMC_DATA_READ)
+		mode |= (1 << 4);
+
+	writew(mode, &host->reg->trnmod);
+}
+
+static int mmc_send_cmd(struct mci_host *mci_host, struct mci_cmd *cmd,
+			struct mci_data *data)
+{
+	struct mmc_host *host = to_s3c_host(mci_host);
+	int flags, i;
+	unsigned int timeout;
+	unsigned int mask;
+	unsigned int retry = 0x100000;
+
+	/* Wait max 10 ms */
+	timeout = 10;
+
+	/*
+	 * PRNSTS
+	 * CMDINHDAT[1]	: Command Inhibit (DAT)
+	 * CMDINHCMD[0]	: Command Inhibit (CMD)
+	 */
+	mask = (1 << 0);
+	if ((data != NULL) || (cmd->resp_type & MMC_RSP_BUSY))
+		mask |= (1 << 1);
+
+	/*
+	 * We shouldn't wait for data inihibit for stop commands, even
+	 * though they might use busy signaling
+	 */
+	if (data)
+		mask &= ~(1 << 1);
+
+	while (readl(&host->reg->prnsts) & mask) {
+		if (timeout == 0) {
+			printf("%s: timeout error\n", __func__);
+			return -1;
+		}
+		timeout--;
+		udelay(1000);
+	}
+
+	if (data)
+		mmc_prepare_data(host, data);
+
+	debug("cmd->arg: %08x\n", cmd->cmdarg);
+	writel(cmd->cmdarg, &host->reg->argument);
+
+	if (data)
+		mmc_set_transfer_mode(host, data);
+
+	if ((cmd->resp_type & MMC_RSP_136) && (cmd->resp_type & MMC_RSP_BUSY))
+		return -1;
+
+	/*
+	 * CMDREG
+	 * CMDIDX[13:8]	: Command index
+	 * DATAPRNT[5]	: Data Present Select
+	 * ENCMDIDX[4]	: Command Index Check Enable
+	 * ENCMDCRC[3]	: Command CRC Check Enable
+	 * RSPTYP[1:0]
+	 *	00 = No Response
+	 *	01 = Length 136
+	 *	10 = Length 48
+	 *	11 = Length 48 Check busy after response
+	 */
+	if (!(cmd->resp_type & MMC_RSP_PRESENT))
+		flags = 0;
+	else if (cmd->resp_type & MMC_RSP_136)
+		flags = (1 << 0);
+	else if (cmd->resp_type & MMC_RSP_BUSY)
+		flags = (3 << 0);
+	else
+		flags = (2 << 0);
+
+	if (cmd->resp_type & MMC_RSP_CRC)
+		flags |= (1 << 3);
+	if (cmd->resp_type & MMC_RSP_OPCODE)
+		flags |= (1 << 4);
+	if (data)
+		flags |= (1 << 5);
+
+	debug("cmd: %d\n", cmd->cmdidx);
+
+	writew((cmd->cmdidx << 8) | flags, &host->reg->cmdreg);
+
+	for (i = 0; i < retry; i++) {
+		mask = readl(&host->reg->norintsts);
+		/* Command Complete */
+		if (mask & (1 << 0)) {
+			if (!data)
+				writel(mask, &host->reg->norintsts);
+			break;
+		}
+	}
+
+	if (i == retry) {
+		printf("%s: waiting for status update\n", __func__);
+		return -ETIMEDOUT;
+	}
+
+	if (mask & (1 << 16)) {
+		/* Timeout Error */
+		debug("timeout: %08x cmd %d\n", mask, cmd->cmdidx);
+		return -ETIMEDOUT;
+	} else if (mask & (1 << 15)) {
+		/* Error Interrupt */
+		debug("error: %08x cmd %d\n", mask, cmd->cmdidx);
+		return -1;
+	}
+
+	if (cmd->resp_type & MMC_RSP_PRESENT) {
+		if (cmd->resp_type & MMC_RSP_136) {
+			/* CRC is stripped so we need to do some shifting. */
+			for (i = 0; i < 4; i++) {
+				unsigned int offset =
+					(unsigned int)(&host->reg->rspreg3 - i);
+				cmd->response[i] = readl(offset) << 8;
+
+				if (i != 3) {
+					cmd->response[i] |=
+						readb(offset - 1);
+				}
+				debug("cmd->resp[%d]: %08x\n",
+						i, cmd->response[i]);
+			}
+		} else if (cmd->resp_type & MMC_RSP_BUSY) {
+			for (i = 0; i < retry; i++) {
+				/* PRNTDATA[23:20] : DAT[3:0] Line Signal */
+				if (readl(&host->reg->prnsts)
+					& (1 << 20))	/* DAT[0] */
+					break;
+			}
+
+			if (i == retry) {
+				printf("%s: card is still busy\n", __func__);
+				return -ETIMEDOUT;
+			}
+
+			cmd->response[0] = readl(&host->reg->rspreg0);
+			debug("cmd->resp[0]: %08x\n", cmd->response[0]);
+		} else {
+			cmd->response[0] = readl(&host->reg->rspreg0);
+			debug("cmd->resp[0]: %08x\n", cmd->response[0]);
+		}
+	}
+
+	if (data) {
+		while (1) {
+			mask = readl(&host->reg->norintsts);
+
+			if (mask & (1 << 15)) {
+				/* Error Interrupt */
+				writel(mask, &host->reg->norintsts);
+				printf("%s: error during transfer: 0x%08x\n",
+						__func__, mask);
+				return -1;
+			} else if (mask & (1 << 3)) {
+				/* DMA Interrupt */
+				debug("DMA end\n");
+				break;
+			} else if (mask & (1 << 1)) {
+				/* Transfer Complete */
+				debug("r/w is done\n");
+				break;
+			}
+		}
+		writel(mask, &host->reg->norintsts);
+	}
+
+	udelay(1000);
+	return 0;
+}
+
+static void mmc_change_clock(struct mmc_host *host, uint clock)
+{
+	int div;
+	unsigned short clk;
+	unsigned long timeout;
+	unsigned long ctrl2;
+
+	/*
+	 * SELBASECLK[5:4]
+	 * 00/01 = HCLK
+	 * 10 = EPLL
+	 * 11 = XTI or XEXTCLK
+	 */
+	ctrl2 = readl(&host->reg->control2);
+	ctrl2 &= ~(3 << 4);
+	ctrl2 |= (2 << 4);
+	writel(ctrl2, &host->reg->control2);
+
+	writew(0, &host->reg->clkcon);
+
+	/* XXX: we assume that clock is between 40MHz and 50MHz */
+	if (clock == 0)
+		goto out;
+	else if (clock <= 400000)
+		div = 0x100;
+	else if (clock <= 20000000)
+		div = 4;
+	else if (clock <= 26000000)
+		div = 2;
+	else
+		div = 1;
+	debug("div: %d\n", div);
+
+	div >>= 1;
+	/*
+	 * CLKCON
+	 * SELFREQ[15:8]	: base clock divied by value
+	 * ENSDCLK[2]		: SD Clock Enable
+	 * STBLINTCLK[1]	: Internal Clock Stable
+	 * ENINTCLK[0]		: Internal Clock Enable
+	 */
+	clk = (div << 8) | (1 << 0);
+	writew(clk, &host->reg->clkcon);
+
+	/* Wait max 10 ms */
+	timeout = 10;
+	while (!(readw(&host->reg->clkcon) & (1 << 1))) {
+		if (timeout == 0) {
+			printf("%s: timeout error\n", __func__);
+			return;
+		}
+		timeout--;
+		udelay(1000);
+	}
+
+	clk |= (1 << 2);
+	writew(clk, &host->reg->clkcon);
+
+out:
+	host->clock = clock;
+}
+
+static void mmc_set_ios(struct mci_host *mci_host, struct mci_ios *ios)
+{
+	struct mmc_host *host = to_s3c_host(mci_host);
+	unsigned char ctrl;
+	unsigned long val;
+
+	debug("bus_width: %x, clock: %d\n", ios->bus_width, ios->clock);
+
+	/*
+	 * SELCLKPADDS[17:16]
+	 * 00 = 2mA
+	 * 01 = 4mA
+	 * 10 = 7mA
+	 * 11 = 9mA
+	 */
+	writel(0x3 << 16, &host->reg->control4);
+
+	val = readl(&host->reg->control2);
+	val &= (0x3 << 4);
+
+	val |=	(1 << 31) |	/* write status clear async mode enable */
+		(1 << 30) |	/* command conflict mask enable */
+		(1 << 14) |	/* Feedback Clock Enable for Rx Clock */
+		(1 << 8);	/* SDCLK hold enable */
+
+	writel(val, &host->reg->control2);
+
+	/*
+	 * FCSEL1[15] FCSEL0[7]
+	 * FCSel[1:0] : Rx Feedback Clock Delay Control
+	 *	Inverter delay means10ns delay if SDCLK 50MHz setting
+	 *	01 = Delay1 (basic delay)
+	 *	11 = Delay2 (basic delay + 2ns)
+	 *	00 = Delay3 (inverter delay)
+	 *	10 = Delay4 (inverter delay + 2ns)
+	 */
+	writel(0x8080, &host->reg->control3);
+
+	mmc_change_clock(host, ios->clock);
+
+	ctrl = readb(&host->reg->hostctl);
+
+	/*
+	 * WIDE4[1]
+	 * 1 = 4-bit mode
+	 * 0 = 1-bit mode
+	 */
+	switch (ios->bus_width) {
+	case MMC_BUS_WIDTH_4:
+		ctrl |= (1 << 1);
+		break;
+	case MMC_BUS_WIDTH_1:
+		ctrl &= ~(1 << 1);
+		break;
+	default:
+		pr_err("sdhci: unkown bus_width");
+	}
+
+	/*
+	 * OUTEDGEINV[2]
+	 * 1 = Riging edge output
+	 * 0 = Falling edge output
+	 */
+	ctrl &= ~(1 << 2);
+
+	writeb(ctrl, &host->reg->hostctl);
+}
+
+static void mmc_reset(struct mmc_host *host)
+{
+	unsigned int timeout;
+
+	/*
+	 * RSTALL[0] : Software reset for all
+	 * 1 = reset
+	 * 0 = work
+	 */
+	writeb((1 << 0), &host->reg->swrst);
+
+	host->clock = 0;
+
+	/* Wait max 100 ms */
+	timeout = 100;
+
+	/* hw clears the bit when it's done */
+	while (readb(&host->reg->swrst) & (1 << 0)) {
+		if (timeout == 0) {
+			printf("%s: timeout error\n", __func__);
+			return;
+		}
+		timeout--;
+		udelay(1000);
+	}
+}
+
+static int mmc_core_init(struct mci_host *mci_host, struct device_d *mci_dev)
+{
+	struct mmc_host *host = to_s3c_host(mci_host);
+	unsigned int mask;
+#if 0
+	if (mmc_card_detect(host) == 0) {
+		printf("NO SD/MMC detected!\n");
+		return -1;
+	}
+#endif
+	mmc_reset(host);
+
+	host->version = readw(&host->reg->hcver);
+
+	/* mask all */
+	writel(0xffffffff, &host->reg->norintstsen);
+	writel(0xffffffff, &host->reg->norintsigen);
+
+	writeb(0xe, &host->reg->timeoutcon);	/* TMCLK * 2^27 */
+
+	/*
+	 * NORMAL Interrupt Status Enable Register init
+	 * [5] ENSTABUFRDRDY : Buffer Read Ready Status Enable
+	 * [4] ENSTABUFWTRDY : Buffer write Ready Status Enable
+	 * [1] ENSTASTANSCMPLT : Transfre Complete Status Enable
+	 * [0] ENSTACMDCMPLT : Command Complete Status Enable
+	*/
+	mask = readl(&host->reg->norintstsen);
+	mask &= ~(0xffff);
+	mask |= (1 << 5) | (1 << 4) | (1 << 1) | (1 << 0);
+	writel(mask, &host->reg->norintstsen);
+
+	/*
+	 * NORMAL Interrupt Signal Enable Register init
+	 * [1] ENSTACMDCMPLT : Transfer Complete Signal Enable
+	 */
+	mask = readl(&host->reg->norintsigen);
+	mask &= ~(0xffff);
+	mask |= (1 << 1);
+	writel(mask, &host->reg->norintsigen);
+
+	return 0;
+}
+
+static int sdhci_s3c_probe(struct device_d *hw_dev)
+{
+	//struct s3c_mci_platform_data *pdata = hw_dev->platform_data;
+	struct mmc_host *s3c_host;
+
+	//if (!pdata) {
+	//	pr_err("s3c-sdhci: no device data specified\n");
+	//	return -ENOENT;
+	//}
+
+	s3c_host = xzalloc(sizeof(*s3c_host));
+	s3c_host->host.send_cmd = mmc_send_cmd;
+	s3c_host->host.set_ios = mmc_set_ios;
+	s3c_host->host.init = mmc_core_init;
+	s3c_host->host.card_present = mmc_card_detect;
+
+	hw_dev->priv = s3c_host;
+	s3c_host->reg = dev_request_mem_region(hw_dev, 0);
+	s3c_host->host.hw_dev = hw_dev;
+
+	/* feed forward the platform specific values */
+	s3c_host->host.voltages = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195;
+	s3c_host->host.host_caps = MMC_CAP_4_BIT_DATA | MMC_CAP_MMC_HIGHSPEED_52MHZ | MMC_CAP_MMC_HIGHSPEED;
+
+	s3c_host->host.f_min = 400000;
+	s3c_host->host.f_max = 52000000;
+
+	s3c_host->clock = 0;
+
+	return mci_register(&s3c_host->host);
+}
+
+static struct driver_d sdhci_s3c_driver = {
+	.probe	= sdhci_s3c_probe,
+	.name	= "s3c-sdhci",
+};
+
+device_platform_driver(sdhci_s3c_driver);
Index: barebox-2014.10.0/arch/arm/mach-samsung/mmc_boot.c
===================================================================
--- /dev/null
+++ barebox-2014.10.0/arch/arm/mach-samsung/mmc_boot.c
@@ -0,0 +1,36 @@
+#include <config.h>
+#include <common.h>
+#include <init.h>
+#include <io.h>
+#include <asm/sections.h>
+
+#define MMC_BLKSIZE		(512)
+
+#define MMC_BASE_ADDR		(*((volatile unsigned int *)0x0C003FEC))
+#define MMC_INFO		(*((volatile unsigned int *)0x0C003FF8))
+#define MMC_TOTAL_BLKCNT	(*((volatile unsigned int *)0x0C003FFC))
+#define MMC_COPY_FUNC		(*((volatile unsigned int *)0x0C004008))
+
+#define BL2_BLK_CNT		(CONFIG_BAREBOX_MAX_IMAGE_SIZE/MMC_BLKSIZE)
+
+/**
+ * This Function copies SD/MMC Card Data to memory.
+ * Always use EPLL source clock.
+ * @param channel : HSMMC Controller channel number ( Not support. Depend on GPN15, GPN14 and GPN13 )
+ * @param StartBlkAddress : Source card(SD/MMC) Address.(It must block address.)
+ * @param blockSize : Number of blocks to copy.
+ * @param memoryPtr : Buffer to copy from.
+ * @param with_init : reinitialize or not
+ * @return bool(unsigend char) - Success or failure.
+ */
+#define CopyMMCtoMem(z,a,b,c,e)  (((bool(*)(int, unsigned int, unsigned short, unsigned int*, bool)) \
+	MMC_COPY_FUNC)(z,a,b,c,e))
+
+void __bare_init s3c_mmc_boot(void)
+{
+	u32 __iomem * mmc_control4 = (void *)(MMC_BASE_ADDR + 0x8C);
+	const unsigned int bl2_blk_pos = MMC_TOTAL_BLKCNT - (BL2_BLK_CNT + 18);
+
+	writel(readl(mmc_control4) | (0x3 << 16), mmc_control4);
+	CopyMMCtoMem(0, bl2_blk_pos, BL2_BLK_CNT, (unsigned int *)(_text), 0);
+}
Index: barebox-2014.10.0/arch/arm/Makefile
===================================================================
--- barebox-2014.10.0.orig/arch/arm/Makefile
+++ barebox-2014.10.0/arch/arm/Makefile
@@ -89,6 +89,7 @@ board-$(CONFIG_MACH_A9M2440)			+= a9m244
 board-$(CONFIG_MACH_AT91RM9200EK)		+= at91rm9200ek
 board-$(CONFIG_MACH_MINI2440)			+= friendlyarm-mini2440
 board-$(CONFIG_MACH_MINI6410)			+= friendlyarm-mini6410
+board-$(CONFIG_MACH_ARM11PLF)			+= njjl-arm11plf
 board-$(CONFIG_MACH_PCM027)			+= phytec-phycore-pxa270
 board-$(CONFIG_MACH_TINY210)			+= friendlyarm-tiny210
 board-$(CONFIG_MACH_TINY6410)			+= friendlyarm-tiny6410
Index: barebox-2014.10.0/drivers/mci/Makefile
===================================================================
--- barebox-2014.10.0.orig/drivers/mci/Makefile
+++ barebox-2014.10.0/drivers/mci/Makefile
@@ -7,6 +7,7 @@ obj-$(CONFIG_MCI_MXS)		+= mxs.o
 obj-$(CONFIG_MCI_OMAP_HSMMC)	+= omap_hsmmc.o
 obj-$(CONFIG_MCI_PXA)		+= pxamci.o
 obj-$(CONFIG_MCI_S3C)		+= s3c.o
+obj-$(CONFIG_MCI_S3C64XX)	+= sdhci-s3c.o
 obj-$(CONFIG_MCI_TEGRA)		+= tegra-sdmmc.o
 obj-$(CONFIG_MCI_SPI)		+= mci_spi.o
 obj-$(CONFIG_MCI_DW)		+= dw_mmc.o
Index: barebox-2014.10.0/arch/arm/boards/njjl-arm11plf/env/bin/init
===================================================================
--- /dev/null
+++ barebox-2014.10.0/arch/arm/boards/njjl-arm11plf/env/bin/init
@@ -0,0 +1,62 @@
+#!/bin/sh
+
+export PATH=/env/bin
+
+nand_parts="512K(bl),512K(env),5M(mk),5M(sk),-(ubifs)"
+addpart /dev/nand0 $nand_parts
+
+bootargs_cmm="console=ttySAC0,115200 mtdparts=nand:$nand_parts"
+
+if [ "${bootsource}" = "nand" ]; then
+
+	#nand boot
+
+	# just for debug, hit any key to stop auto boot
+	timeout -a 0
+	if [ $? != 0 ]; then
+		exit
+	fi
+
+	# load env
+	loadenv /dev/nand0.env.bb /env
+	. /env/config
+
+	if [ -z $prd_boot_sel ]; then
+		prd_boot_sel=m
+	fi
+
+	if [ -z ${MBVer} ]; then
+		MBVer=${adc1}
+	fi
+
+	# start linux
+	bootargs="${bootargs_cmm} quiet noinitrd ubi.mtd=ubifs rootfstype=ubifs root=ubi0:${prd_boot_sel}r prd_boot_sel=${prd_boot_sel} hw_cfg=${hw_cfg} MBVer=${MBVer}"
+	bootm /dev/nand0.${prd_boot_sel}k.bb
+
+	if [ "$prd_boot_sel" = "m" ]; then
+		prd_boot_sel=s
+	else
+		prd_boot_sel=m
+	fi
+
+	# start the other part
+	bootargs="${bootargs_cmm} quiet noinitrd ubi.mtd=ubifs rootfstype=ubifs root=ubi0:${prd_boot_sel}r prd_boot_sel=${prd_boot_sel} hw_cfg=${hw_cfg} MBVer=${MBVer}"
+	bootm /dev/nand0.${prd_boot_sel}k.bb
+else
+	# mmc boot
+	mci0.probe=1
+	mkdir /mmc
+	mount /dev/disk0.0 /mmc
+
+	#mmc boot args
+	bootargs="$bootargs_cmm root=/dev/ram rw ramdisk_size=65536 MBVer=${adc1}"
+
+	echo
+	echo -n "Hit any key to stop autoboot: "
+	timeout -a 3
+	if [ $? != 0 ]; then
+		exit
+	fi
+
+	bootm -r /mmc/j-initramfs /mmc/j-zImage
+fi
